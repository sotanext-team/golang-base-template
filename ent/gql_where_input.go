// Code generated by entc, DO NOT EDIT.

package ent

import (
	"app-api/ent/bktemplatesection"
	"app-api/ent/componentproperty"
	"app-api/ent/customcomponent"
	"app-api/ent/globaltemplate"
	"app-api/ent/predicate"
	"app-api/ent/shop"
	"app-api/ent/templatesection"
	"app-api/ent/templatesectionversion"
	"app-api/ent/theme"
	"app-api/ent/themetemplate"
	"app-api/ent/todo"
	"fmt"
	"time"
)

// BkTemplateSectionWhereInput represents a where input for filtering BkTemplateSection queries.
type BkTemplateSectionWhereInput struct {
	Not *BkTemplateSectionWhereInput   `json:"not,omitempty"`
	Or  []*BkTemplateSectionWhereInput `json:"or,omitempty"`
	And []*BkTemplateSectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "version_id" field predicates.
	VersionID       *uint64  `json:"versionID,omitempty"`
	VersionIDNEQ    *uint64  `json:"versionIDNEQ,omitempty"`
	VersionIDIn     []uint64 `json:"versionIDIn,omitempty"`
	VersionIDNotIn  []uint64 `json:"versionIDNotIn,omitempty"`
	VersionIDIsNil  bool     `json:"versionIDIsNil,omitempty"`
	VersionIDNotNil bool     `json:"versionIDNotNil,omitempty"`

	// "data" field predicates.
	Data             *string  `json:"data,omitempty"`
	DataNEQ          *string  `json:"dataNEQ,omitempty"`
	DataIn           []string `json:"dataIn,omitempty"`
	DataNotIn        []string `json:"dataNotIn,omitempty"`
	DataGT           *string  `json:"dataGT,omitempty"`
	DataGTE          *string  `json:"dataGTE,omitempty"`
	DataLT           *string  `json:"dataLT,omitempty"`
	DataLTE          *string  `json:"dataLTE,omitempty"`
	DataContains     *string  `json:"dataContains,omitempty"`
	DataHasPrefix    *string  `json:"dataHasPrefix,omitempty"`
	DataHasSuffix    *string  `json:"dataHasSuffix,omitempty"`
	DataEqualFold    *string  `json:"dataEqualFold,omitempty"`
	DataContainsFold *string  `json:"dataContainsFold,omitempty"`

	// "templateSection" edge predicates.
	HasTemplateSection     *bool                        `json:"hasTemplateSection,omitempty"`
	HasTemplateSectionWith []*TemplateSectionWhereInput `json:"hasTemplateSectionWith,omitempty"`

	// "version" edge predicates.
	HasVersion     *bool                               `json:"hasVersion,omitempty"`
	HasVersionWith []*TemplateSectionVersionWhereInput `json:"hasVersionWith,omitempty"`
}

// Filter applies the BkTemplateSectionWhereInput filter on the BkTemplateSectionQuery builder.
func (i *BkTemplateSectionWhereInput) Filter(q *BkTemplateSectionQuery) (*BkTemplateSectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering bktemplatesections.
// An error is returned if the input is empty or invalid.
func (i *BkTemplateSectionWhereInput) P() (predicate.BkTemplateSection, error) {
	var predicates []predicate.BkTemplateSection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, bktemplatesection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BkTemplateSection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, bktemplatesection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BkTemplateSection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, bktemplatesection.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, bktemplatesection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bktemplatesection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bktemplatesection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bktemplatesection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bktemplatesection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bktemplatesection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bktemplatesection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bktemplatesection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, bktemplatesection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, bktemplatesection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, bktemplatesection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, bktemplatesection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, bktemplatesection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, bktemplatesection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.VersionID != nil {
		predicates = append(predicates, bktemplatesection.VersionIDEQ(*i.VersionID))
	}
	if i.VersionIDNEQ != nil {
		predicates = append(predicates, bktemplatesection.VersionIDNEQ(*i.VersionIDNEQ))
	}
	if len(i.VersionIDIn) > 0 {
		predicates = append(predicates, bktemplatesection.VersionIDIn(i.VersionIDIn...))
	}
	if len(i.VersionIDNotIn) > 0 {
		predicates = append(predicates, bktemplatesection.VersionIDNotIn(i.VersionIDNotIn...))
	}
	if i.VersionIDIsNil {
		predicates = append(predicates, bktemplatesection.VersionIDIsNil())
	}
	if i.VersionIDNotNil {
		predicates = append(predicates, bktemplatesection.VersionIDNotNil())
	}
	if i.Data != nil {
		predicates = append(predicates, bktemplatesection.DataEQ(*i.Data))
	}
	if i.DataNEQ != nil {
		predicates = append(predicates, bktemplatesection.DataNEQ(*i.DataNEQ))
	}
	if len(i.DataIn) > 0 {
		predicates = append(predicates, bktemplatesection.DataIn(i.DataIn...))
	}
	if len(i.DataNotIn) > 0 {
		predicates = append(predicates, bktemplatesection.DataNotIn(i.DataNotIn...))
	}
	if i.DataGT != nil {
		predicates = append(predicates, bktemplatesection.DataGT(*i.DataGT))
	}
	if i.DataGTE != nil {
		predicates = append(predicates, bktemplatesection.DataGTE(*i.DataGTE))
	}
	if i.DataLT != nil {
		predicates = append(predicates, bktemplatesection.DataLT(*i.DataLT))
	}
	if i.DataLTE != nil {
		predicates = append(predicates, bktemplatesection.DataLTE(*i.DataLTE))
	}
	if i.DataContains != nil {
		predicates = append(predicates, bktemplatesection.DataContains(*i.DataContains))
	}
	if i.DataHasPrefix != nil {
		predicates = append(predicates, bktemplatesection.DataHasPrefix(*i.DataHasPrefix))
	}
	if i.DataHasSuffix != nil {
		predicates = append(predicates, bktemplatesection.DataHasSuffix(*i.DataHasSuffix))
	}
	if i.DataEqualFold != nil {
		predicates = append(predicates, bktemplatesection.DataEqualFold(*i.DataEqualFold))
	}
	if i.DataContainsFold != nil {
		predicates = append(predicates, bktemplatesection.DataContainsFold(*i.DataContainsFold))
	}

	if i.HasTemplateSection != nil {
		p := bktemplatesection.HasTemplateSection()
		if !*i.HasTemplateSection {
			p = bktemplatesection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTemplateSectionWith) > 0 {
		with := make([]predicate.TemplateSection, 0, len(i.HasTemplateSectionWith))
		for _, w := range i.HasTemplateSectionWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bktemplatesection.HasTemplateSectionWith(with...))
	}
	if i.HasVersion != nil {
		p := bktemplatesection.HasVersion()
		if !*i.HasVersion {
			p = bktemplatesection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVersionWith) > 0 {
		with := make([]predicate.TemplateSectionVersion, 0, len(i.HasVersionWith))
		for _, w := range i.HasVersionWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, bktemplatesection.HasVersionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate BkTemplateSectionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return bktemplatesection.And(predicates...), nil
	}
}

// ComponentPropertyWhereInput represents a where input for filtering ComponentProperty queries.
type ComponentPropertyWhereInput struct {
	Not *ComponentPropertyWhereInput   `json:"not,omitempty"`
	Or  []*ComponentPropertyWhereInput `json:"or,omitempty"`
	And []*ComponentPropertyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "component_id" field predicates.
	ComponentID      *uint64  `json:"componentID,omitempty"`
	ComponentIDNEQ   *uint64  `json:"componentIDNEQ,omitempty"`
	ComponentIDIn    []uint64 `json:"componentIDIn,omitempty"`
	ComponentIDNotIn []uint64 `json:"componentIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "component" edge predicates.
	HasComponent     *bool                        `json:"hasComponent,omitempty"`
	HasComponentWith []*CustomComponentWhereInput `json:"hasComponentWith,omitempty"`
}

// Filter applies the ComponentPropertyWhereInput filter on the ComponentPropertyQuery builder.
func (i *ComponentPropertyWhereInput) Filter(q *ComponentPropertyQuery) (*ComponentPropertyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering componentproperties.
// An error is returned if the input is empty or invalid.
func (i *ComponentPropertyWhereInput) P() (predicate.ComponentProperty, error) {
	var predicates []predicate.ComponentProperty
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, componentproperty.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ComponentProperty, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, componentproperty.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ComponentProperty, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, componentproperty.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, componentproperty.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, componentproperty.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, componentproperty.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, componentproperty.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, componentproperty.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, componentproperty.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, componentproperty.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, componentproperty.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, componentproperty.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, componentproperty.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, componentproperty.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, componentproperty.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, componentproperty.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, componentproperty.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, componentproperty.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, componentproperty.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, componentproperty.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, componentproperty.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, componentproperty.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, componentproperty.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, componentproperty.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, componentproperty.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, componentproperty.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, componentproperty.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ComponentID != nil {
		predicates = append(predicates, componentproperty.ComponentIDEQ(*i.ComponentID))
	}
	if i.ComponentIDNEQ != nil {
		predicates = append(predicates, componentproperty.ComponentIDNEQ(*i.ComponentIDNEQ))
	}
	if len(i.ComponentIDIn) > 0 {
		predicates = append(predicates, componentproperty.ComponentIDIn(i.ComponentIDIn...))
	}
	if len(i.ComponentIDNotIn) > 0 {
		predicates = append(predicates, componentproperty.ComponentIDNotIn(i.ComponentIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, componentproperty.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, componentproperty.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, componentproperty.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, componentproperty.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, componentproperty.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, componentproperty.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, componentproperty.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, componentproperty.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, componentproperty.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, componentproperty.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, componentproperty.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, componentproperty.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, componentproperty.NameContainsFold(*i.NameContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, componentproperty.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, componentproperty.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, componentproperty.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, componentproperty.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, componentproperty.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, componentproperty.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, componentproperty.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, componentproperty.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, componentproperty.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, componentproperty.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, componentproperty.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, componentproperty.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, componentproperty.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasComponent != nil {
		p := componentproperty.HasComponent()
		if !*i.HasComponent {
			p = componentproperty.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentWith) > 0 {
		with := make([]predicate.CustomComponent, 0, len(i.HasComponentWith))
		for _, w := range i.HasComponentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, componentproperty.HasComponentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate ComponentPropertyWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return componentproperty.And(predicates...), nil
	}
}

// CustomComponentWhereInput represents a where input for filtering CustomComponent queries.
type CustomComponentWhereInput struct {
	Not *CustomComponentWhereInput   `json:"not,omitempty"`
	Or  []*CustomComponentWhereInput `json:"or,omitempty"`
	And []*CustomComponentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "handle" field predicates.
	Handle             *string  `json:"handle,omitempty"`
	HandleNEQ          *string  `json:"handleNEQ,omitempty"`
	HandleIn           []string `json:"handleIn,omitempty"`
	HandleNotIn        []string `json:"handleNotIn,omitempty"`
	HandleGT           *string  `json:"handleGT,omitempty"`
	HandleGTE          *string  `json:"handleGTE,omitempty"`
	HandleLT           *string  `json:"handleLT,omitempty"`
	HandleLTE          *string  `json:"handleLTE,omitempty"`
	HandleContains     *string  `json:"handleContains,omitempty"`
	HandleHasPrefix    *string  `json:"handleHasPrefix,omitempty"`
	HandleHasSuffix    *string  `json:"handleHasSuffix,omitempty"`
	HandleEqualFold    *string  `json:"handleEqualFold,omitempty"`
	HandleContainsFold *string  `json:"handleContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "dist_url" field predicates.
	DistURL             *string  `json:"distURL,omitempty"`
	DistURLNEQ          *string  `json:"distURLNEQ,omitempty"`
	DistURLIn           []string `json:"distURLIn,omitempty"`
	DistURLNotIn        []string `json:"distURLNotIn,omitempty"`
	DistURLGT           *string  `json:"distURLGT,omitempty"`
	DistURLGTE          *string  `json:"distURLGTE,omitempty"`
	DistURLLT           *string  `json:"distURLLT,omitempty"`
	DistURLLTE          *string  `json:"distURLLTE,omitempty"`
	DistURLContains     *string  `json:"distURLContains,omitempty"`
	DistURLHasPrefix    *string  `json:"distURLHasPrefix,omitempty"`
	DistURLHasSuffix    *string  `json:"distURLHasSuffix,omitempty"`
	DistURLIsNil        bool     `json:"distURLIsNil,omitempty"`
	DistURLNotNil       bool     `json:"distURLNotNil,omitempty"`
	DistURLEqualFold    *string  `json:"distURLEqualFold,omitempty"`
	DistURLContainsFold *string  `json:"distURLContainsFold,omitempty"`

	// "is_draft" field predicates.
	IsDraft       *bool `json:"isDraft,omitempty"`
	IsDraftNEQ    *bool `json:"isDraftNEQ,omitempty"`
	IsDraftIsNil  bool  `json:"isDraftIsNil,omitempty"`
	IsDraftNotNil bool  `json:"isDraftNotNil,omitempty"`

	// "entry_file_name" field predicates.
	EntryFileName             *string  `json:"entryFileName,omitempty"`
	EntryFileNameNEQ          *string  `json:"entryFileNameNEQ,omitempty"`
	EntryFileNameIn           []string `json:"entryFileNameIn,omitempty"`
	EntryFileNameNotIn        []string `json:"entryFileNameNotIn,omitempty"`
	EntryFileNameGT           *string  `json:"entryFileNameGT,omitempty"`
	EntryFileNameGTE          *string  `json:"entryFileNameGTE,omitempty"`
	EntryFileNameLT           *string  `json:"entryFileNameLT,omitempty"`
	EntryFileNameLTE          *string  `json:"entryFileNameLTE,omitempty"`
	EntryFileNameContains     *string  `json:"entryFileNameContains,omitempty"`
	EntryFileNameHasPrefix    *string  `json:"entryFileNameHasPrefix,omitempty"`
	EntryFileNameHasSuffix    *string  `json:"entryFileNameHasSuffix,omitempty"`
	EntryFileNameIsNil        bool     `json:"entryFileNameIsNil,omitempty"`
	EntryFileNameNotNil       bool     `json:"entryFileNameNotNil,omitempty"`
	EntryFileNameEqualFold    *string  `json:"entryFileNameEqualFold,omitempty"`
	EntryFileNameContainsFold *string  `json:"entryFileNameContainsFold,omitempty"`

	// "props" edge predicates.
	HasProps     *bool                          `json:"hasProps,omitempty"`
	HasPropsWith []*ComponentPropertyWhereInput `json:"hasPropsWith,omitempty"`
}

// Filter applies the CustomComponentWhereInput filter on the CustomComponentQuery builder.
func (i *CustomComponentWhereInput) Filter(q *CustomComponentQuery) (*CustomComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering customcomponents.
// An error is returned if the input is empty or invalid.
func (i *CustomComponentWhereInput) P() (predicate.CustomComponent, error) {
	var predicates []predicate.CustomComponent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, customcomponent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomComponent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, customcomponent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomComponent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, customcomponent.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, customcomponent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customcomponent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customcomponent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customcomponent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customcomponent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customcomponent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customcomponent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customcomponent.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customcomponent.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customcomponent.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customcomponent.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customcomponent.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customcomponent.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customcomponent.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customcomponent.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customcomponent.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customcomponent.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customcomponent.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customcomponent.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customcomponent.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customcomponent.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customcomponent.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customcomponent.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customcomponent.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, customcomponent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customcomponent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customcomponent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customcomponent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customcomponent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customcomponent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customcomponent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customcomponent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customcomponent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customcomponent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customcomponent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customcomponent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customcomponent.NameContainsFold(*i.NameContainsFold))
	}
	if i.Handle != nil {
		predicates = append(predicates, customcomponent.HandleEQ(*i.Handle))
	}
	if i.HandleNEQ != nil {
		predicates = append(predicates, customcomponent.HandleNEQ(*i.HandleNEQ))
	}
	if len(i.HandleIn) > 0 {
		predicates = append(predicates, customcomponent.HandleIn(i.HandleIn...))
	}
	if len(i.HandleNotIn) > 0 {
		predicates = append(predicates, customcomponent.HandleNotIn(i.HandleNotIn...))
	}
	if i.HandleGT != nil {
		predicates = append(predicates, customcomponent.HandleGT(*i.HandleGT))
	}
	if i.HandleGTE != nil {
		predicates = append(predicates, customcomponent.HandleGTE(*i.HandleGTE))
	}
	if i.HandleLT != nil {
		predicates = append(predicates, customcomponent.HandleLT(*i.HandleLT))
	}
	if i.HandleLTE != nil {
		predicates = append(predicates, customcomponent.HandleLTE(*i.HandleLTE))
	}
	if i.HandleContains != nil {
		predicates = append(predicates, customcomponent.HandleContains(*i.HandleContains))
	}
	if i.HandleHasPrefix != nil {
		predicates = append(predicates, customcomponent.HandleHasPrefix(*i.HandleHasPrefix))
	}
	if i.HandleHasSuffix != nil {
		predicates = append(predicates, customcomponent.HandleHasSuffix(*i.HandleHasSuffix))
	}
	if i.HandleEqualFold != nil {
		predicates = append(predicates, customcomponent.HandleEqualFold(*i.HandleEqualFold))
	}
	if i.HandleContainsFold != nil {
		predicates = append(predicates, customcomponent.HandleContainsFold(*i.HandleContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, customcomponent.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, customcomponent.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, customcomponent.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, customcomponent.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, customcomponent.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, customcomponent.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, customcomponent.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, customcomponent.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, customcomponent.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, customcomponent.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, customcomponent.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, customcomponent.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, customcomponent.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, customcomponent.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, customcomponent.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.DistURL != nil {
		predicates = append(predicates, customcomponent.DistURLEQ(*i.DistURL))
	}
	if i.DistURLNEQ != nil {
		predicates = append(predicates, customcomponent.DistURLNEQ(*i.DistURLNEQ))
	}
	if len(i.DistURLIn) > 0 {
		predicates = append(predicates, customcomponent.DistURLIn(i.DistURLIn...))
	}
	if len(i.DistURLNotIn) > 0 {
		predicates = append(predicates, customcomponent.DistURLNotIn(i.DistURLNotIn...))
	}
	if i.DistURLGT != nil {
		predicates = append(predicates, customcomponent.DistURLGT(*i.DistURLGT))
	}
	if i.DistURLGTE != nil {
		predicates = append(predicates, customcomponent.DistURLGTE(*i.DistURLGTE))
	}
	if i.DistURLLT != nil {
		predicates = append(predicates, customcomponent.DistURLLT(*i.DistURLLT))
	}
	if i.DistURLLTE != nil {
		predicates = append(predicates, customcomponent.DistURLLTE(*i.DistURLLTE))
	}
	if i.DistURLContains != nil {
		predicates = append(predicates, customcomponent.DistURLContains(*i.DistURLContains))
	}
	if i.DistURLHasPrefix != nil {
		predicates = append(predicates, customcomponent.DistURLHasPrefix(*i.DistURLHasPrefix))
	}
	if i.DistURLHasSuffix != nil {
		predicates = append(predicates, customcomponent.DistURLHasSuffix(*i.DistURLHasSuffix))
	}
	if i.DistURLIsNil {
		predicates = append(predicates, customcomponent.DistURLIsNil())
	}
	if i.DistURLNotNil {
		predicates = append(predicates, customcomponent.DistURLNotNil())
	}
	if i.DistURLEqualFold != nil {
		predicates = append(predicates, customcomponent.DistURLEqualFold(*i.DistURLEqualFold))
	}
	if i.DistURLContainsFold != nil {
		predicates = append(predicates, customcomponent.DistURLContainsFold(*i.DistURLContainsFold))
	}
	if i.IsDraft != nil {
		predicates = append(predicates, customcomponent.IsDraftEQ(*i.IsDraft))
	}
	if i.IsDraftNEQ != nil {
		predicates = append(predicates, customcomponent.IsDraftNEQ(*i.IsDraftNEQ))
	}
	if i.IsDraftIsNil {
		predicates = append(predicates, customcomponent.IsDraftIsNil())
	}
	if i.IsDraftNotNil {
		predicates = append(predicates, customcomponent.IsDraftNotNil())
	}
	if i.EntryFileName != nil {
		predicates = append(predicates, customcomponent.EntryFileNameEQ(*i.EntryFileName))
	}
	if i.EntryFileNameNEQ != nil {
		predicates = append(predicates, customcomponent.EntryFileNameNEQ(*i.EntryFileNameNEQ))
	}
	if len(i.EntryFileNameIn) > 0 {
		predicates = append(predicates, customcomponent.EntryFileNameIn(i.EntryFileNameIn...))
	}
	if len(i.EntryFileNameNotIn) > 0 {
		predicates = append(predicates, customcomponent.EntryFileNameNotIn(i.EntryFileNameNotIn...))
	}
	if i.EntryFileNameGT != nil {
		predicates = append(predicates, customcomponent.EntryFileNameGT(*i.EntryFileNameGT))
	}
	if i.EntryFileNameGTE != nil {
		predicates = append(predicates, customcomponent.EntryFileNameGTE(*i.EntryFileNameGTE))
	}
	if i.EntryFileNameLT != nil {
		predicates = append(predicates, customcomponent.EntryFileNameLT(*i.EntryFileNameLT))
	}
	if i.EntryFileNameLTE != nil {
		predicates = append(predicates, customcomponent.EntryFileNameLTE(*i.EntryFileNameLTE))
	}
	if i.EntryFileNameContains != nil {
		predicates = append(predicates, customcomponent.EntryFileNameContains(*i.EntryFileNameContains))
	}
	if i.EntryFileNameHasPrefix != nil {
		predicates = append(predicates, customcomponent.EntryFileNameHasPrefix(*i.EntryFileNameHasPrefix))
	}
	if i.EntryFileNameHasSuffix != nil {
		predicates = append(predicates, customcomponent.EntryFileNameHasSuffix(*i.EntryFileNameHasSuffix))
	}
	if i.EntryFileNameIsNil {
		predicates = append(predicates, customcomponent.EntryFileNameIsNil())
	}
	if i.EntryFileNameNotNil {
		predicates = append(predicates, customcomponent.EntryFileNameNotNil())
	}
	if i.EntryFileNameEqualFold != nil {
		predicates = append(predicates, customcomponent.EntryFileNameEqualFold(*i.EntryFileNameEqualFold))
	}
	if i.EntryFileNameContainsFold != nil {
		predicates = append(predicates, customcomponent.EntryFileNameContainsFold(*i.EntryFileNameContainsFold))
	}

	if i.HasProps != nil {
		p := customcomponent.HasProps()
		if !*i.HasProps {
			p = customcomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPropsWith) > 0 {
		with := make([]predicate.ComponentProperty, 0, len(i.HasPropsWith))
		for _, w := range i.HasPropsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, customcomponent.HasPropsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate CustomComponentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return customcomponent.And(predicates...), nil
	}
}

// GlobalTemplateWhereInput represents a where input for filtering GlobalTemplate queries.
type GlobalTemplateWhereInput struct {
	Not *GlobalTemplateWhereInput   `json:"not,omitempty"`
	Or  []*GlobalTemplateWhereInput `json:"or,omitempty"`
	And []*GlobalTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "view_count" field predicates.
	ViewCount      *int  `json:"viewCount,omitempty"`
	ViewCountNEQ   *int  `json:"viewCountNEQ,omitempty"`
	ViewCountIn    []int `json:"viewCountIn,omitempty"`
	ViewCountNotIn []int `json:"viewCountNotIn,omitempty"`
	ViewCountGT    *int  `json:"viewCountGT,omitempty"`
	ViewCountGTE   *int  `json:"viewCountGTE,omitempty"`
	ViewCountLT    *int  `json:"viewCountLT,omitempty"`
	ViewCountLTE   *int  `json:"viewCountLTE,omitempty"`

	// "install_count" field predicates.
	InstallCount      *int  `json:"installCount,omitempty"`
	InstallCountNEQ   *int  `json:"installCountNEQ,omitempty"`
	InstallCountIn    []int `json:"installCountIn,omitempty"`
	InstallCountNotIn []int `json:"installCountNotIn,omitempty"`
	InstallCountGT    *int  `json:"installCountGT,omitempty"`
	InstallCountGTE   *int  `json:"installCountGTE,omitempty"`
	InstallCountLT    *int  `json:"installCountLT,omitempty"`
	InstallCountLTE   *int  `json:"installCountLTE,omitempty"`
}

// Filter applies the GlobalTemplateWhereInput filter on the GlobalTemplateQuery builder.
func (i *GlobalTemplateWhereInput) Filter(q *GlobalTemplateQuery) (*GlobalTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering globaltemplates.
// An error is returned if the input is empty or invalid.
func (i *GlobalTemplateWhereInput) P() (predicate.GlobalTemplate, error) {
	var predicates []predicate.GlobalTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, globaltemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GlobalTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, globaltemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GlobalTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, globaltemplate.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, globaltemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, globaltemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, globaltemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, globaltemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, globaltemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, globaltemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, globaltemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, globaltemplate.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, globaltemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, globaltemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, globaltemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, globaltemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, globaltemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, globaltemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, globaltemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, globaltemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, globaltemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, globaltemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, globaltemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, globaltemplate.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, globaltemplate.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, globaltemplate.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, globaltemplate.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, globaltemplate.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, globaltemplate.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, globaltemplate.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, globaltemplate.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, globaltemplate.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, globaltemplate.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, globaltemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, globaltemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, globaltemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, globaltemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, globaltemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, globaltemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, globaltemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, globaltemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, globaltemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, globaltemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, globaltemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, globaltemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, globaltemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.ViewCount != nil {
		predicates = append(predicates, globaltemplate.ViewCountEQ(*i.ViewCount))
	}
	if i.ViewCountNEQ != nil {
		predicates = append(predicates, globaltemplate.ViewCountNEQ(*i.ViewCountNEQ))
	}
	if len(i.ViewCountIn) > 0 {
		predicates = append(predicates, globaltemplate.ViewCountIn(i.ViewCountIn...))
	}
	if len(i.ViewCountNotIn) > 0 {
		predicates = append(predicates, globaltemplate.ViewCountNotIn(i.ViewCountNotIn...))
	}
	if i.ViewCountGT != nil {
		predicates = append(predicates, globaltemplate.ViewCountGT(*i.ViewCountGT))
	}
	if i.ViewCountGTE != nil {
		predicates = append(predicates, globaltemplate.ViewCountGTE(*i.ViewCountGTE))
	}
	if i.ViewCountLT != nil {
		predicates = append(predicates, globaltemplate.ViewCountLT(*i.ViewCountLT))
	}
	if i.ViewCountLTE != nil {
		predicates = append(predicates, globaltemplate.ViewCountLTE(*i.ViewCountLTE))
	}
	if i.InstallCount != nil {
		predicates = append(predicates, globaltemplate.InstallCountEQ(*i.InstallCount))
	}
	if i.InstallCountNEQ != nil {
		predicates = append(predicates, globaltemplate.InstallCountNEQ(*i.InstallCountNEQ))
	}
	if len(i.InstallCountIn) > 0 {
		predicates = append(predicates, globaltemplate.InstallCountIn(i.InstallCountIn...))
	}
	if len(i.InstallCountNotIn) > 0 {
		predicates = append(predicates, globaltemplate.InstallCountNotIn(i.InstallCountNotIn...))
	}
	if i.InstallCountGT != nil {
		predicates = append(predicates, globaltemplate.InstallCountGT(*i.InstallCountGT))
	}
	if i.InstallCountGTE != nil {
		predicates = append(predicates, globaltemplate.InstallCountGTE(*i.InstallCountGTE))
	}
	if i.InstallCountLT != nil {
		predicates = append(predicates, globaltemplate.InstallCountLT(*i.InstallCountLT))
	}
	if i.InstallCountLTE != nil {
		predicates = append(predicates, globaltemplate.InstallCountLTE(*i.InstallCountLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate GlobalTemplateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return globaltemplate.And(predicates...), nil
	}
}

// ShopWhereInput represents a where input for filtering Shop queries.
type ShopWhereInput struct {
	Not *ShopWhereInput   `json:"not,omitempty"`
	Or  []*ShopWhereInput `json:"or,omitempty"`
	And []*ShopWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "shop_name" field predicates.
	ShopName             *string  `json:"shopName,omitempty"`
	ShopNameNEQ          *string  `json:"shopNameNEQ,omitempty"`
	ShopNameIn           []string `json:"shopNameIn,omitempty"`
	ShopNameNotIn        []string `json:"shopNameNotIn,omitempty"`
	ShopNameGT           *string  `json:"shopNameGT,omitempty"`
	ShopNameGTE          *string  `json:"shopNameGTE,omitempty"`
	ShopNameLT           *string  `json:"shopNameLT,omitempty"`
	ShopNameLTE          *string  `json:"shopNameLTE,omitempty"`
	ShopNameContains     *string  `json:"shopNameContains,omitempty"`
	ShopNameHasPrefix    *string  `json:"shopNameHasPrefix,omitempty"`
	ShopNameHasSuffix    *string  `json:"shopNameHasSuffix,omitempty"`
	ShopNameEqualFold    *string  `json:"shopNameEqualFold,omitempty"`
	ShopNameContainsFold *string  `json:"shopNameContainsFold,omitempty"`

	// "default_domain" field predicates.
	DefaultDomain             *string  `json:"defaultDomain,omitempty"`
	DefaultDomainNEQ          *string  `json:"defaultDomainNEQ,omitempty"`
	DefaultDomainIn           []string `json:"defaultDomainIn,omitempty"`
	DefaultDomainNotIn        []string `json:"defaultDomainNotIn,omitempty"`
	DefaultDomainGT           *string  `json:"defaultDomainGT,omitempty"`
	DefaultDomainGTE          *string  `json:"defaultDomainGTE,omitempty"`
	DefaultDomainLT           *string  `json:"defaultDomainLT,omitempty"`
	DefaultDomainLTE          *string  `json:"defaultDomainLTE,omitempty"`
	DefaultDomainContains     *string  `json:"defaultDomainContains,omitempty"`
	DefaultDomainHasPrefix    *string  `json:"defaultDomainHasPrefix,omitempty"`
	DefaultDomainHasSuffix    *string  `json:"defaultDomainHasSuffix,omitempty"`
	DefaultDomainEqualFold    *string  `json:"defaultDomainEqualFold,omitempty"`
	DefaultDomainContainsFold *string  `json:"defaultDomainContainsFold,omitempty"`

	// "custom_domain" field predicates.
	CustomDomain             *string  `json:"customDomain,omitempty"`
	CustomDomainNEQ          *string  `json:"customDomainNEQ,omitempty"`
	CustomDomainIn           []string `json:"customDomainIn,omitempty"`
	CustomDomainNotIn        []string `json:"customDomainNotIn,omitempty"`
	CustomDomainGT           *string  `json:"customDomainGT,omitempty"`
	CustomDomainGTE          *string  `json:"customDomainGTE,omitempty"`
	CustomDomainLT           *string  `json:"customDomainLT,omitempty"`
	CustomDomainLTE          *string  `json:"customDomainLTE,omitempty"`
	CustomDomainContains     *string  `json:"customDomainContains,omitempty"`
	CustomDomainHasPrefix    *string  `json:"customDomainHasPrefix,omitempty"`
	CustomDomainHasSuffix    *string  `json:"customDomainHasSuffix,omitempty"`
	CustomDomainEqualFold    *string  `json:"customDomainEqualFold,omitempty"`
	CustomDomainContainsFold *string  `json:"customDomainContainsFold,omitempty"`

	// "themes" edge predicates.
	HasThemes     *bool              `json:"hasThemes,omitempty"`
	HasThemesWith []*ThemeWhereInput `json:"hasThemesWith,omitempty"`

	// "themeTemplates" edge predicates.
	HasThemeTemplates     *bool                      `json:"hasThemeTemplates,omitempty"`
	HasThemeTemplatesWith []*ThemeTemplateWhereInput `json:"hasThemeTemplatesWith,omitempty"`
}

// Filter applies the ShopWhereInput filter on the ShopQuery builder.
func (i *ShopWhereInput) Filter(q *ShopQuery) (*ShopQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering shops.
// An error is returned if the input is empty or invalid.
func (i *ShopWhereInput) P() (predicate.Shop, error) {
	var predicates []predicate.Shop
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, shop.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Shop, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, shop.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Shop, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, shop.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, shop.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shop.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shop.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shop.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shop.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shop.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shop.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shop.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, shop.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, shop.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, shop.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, shop.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, shop.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, shop.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, shop.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, shop.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, shop.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, shop.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, shop.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, shop.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, shop.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, shop.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, shop.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, shop.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, shop.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, shop.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, shop.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, shop.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, shop.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, shop.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, shop.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, shop.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, shop.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, shop.DeletedAtNotNil())
	}
	if i.ShopName != nil {
		predicates = append(predicates, shop.ShopNameEQ(*i.ShopName))
	}
	if i.ShopNameNEQ != nil {
		predicates = append(predicates, shop.ShopNameNEQ(*i.ShopNameNEQ))
	}
	if len(i.ShopNameIn) > 0 {
		predicates = append(predicates, shop.ShopNameIn(i.ShopNameIn...))
	}
	if len(i.ShopNameNotIn) > 0 {
		predicates = append(predicates, shop.ShopNameNotIn(i.ShopNameNotIn...))
	}
	if i.ShopNameGT != nil {
		predicates = append(predicates, shop.ShopNameGT(*i.ShopNameGT))
	}
	if i.ShopNameGTE != nil {
		predicates = append(predicates, shop.ShopNameGTE(*i.ShopNameGTE))
	}
	if i.ShopNameLT != nil {
		predicates = append(predicates, shop.ShopNameLT(*i.ShopNameLT))
	}
	if i.ShopNameLTE != nil {
		predicates = append(predicates, shop.ShopNameLTE(*i.ShopNameLTE))
	}
	if i.ShopNameContains != nil {
		predicates = append(predicates, shop.ShopNameContains(*i.ShopNameContains))
	}
	if i.ShopNameHasPrefix != nil {
		predicates = append(predicates, shop.ShopNameHasPrefix(*i.ShopNameHasPrefix))
	}
	if i.ShopNameHasSuffix != nil {
		predicates = append(predicates, shop.ShopNameHasSuffix(*i.ShopNameHasSuffix))
	}
	if i.ShopNameEqualFold != nil {
		predicates = append(predicates, shop.ShopNameEqualFold(*i.ShopNameEqualFold))
	}
	if i.ShopNameContainsFold != nil {
		predicates = append(predicates, shop.ShopNameContainsFold(*i.ShopNameContainsFold))
	}
	if i.DefaultDomain != nil {
		predicates = append(predicates, shop.DefaultDomainEQ(*i.DefaultDomain))
	}
	if i.DefaultDomainNEQ != nil {
		predicates = append(predicates, shop.DefaultDomainNEQ(*i.DefaultDomainNEQ))
	}
	if len(i.DefaultDomainIn) > 0 {
		predicates = append(predicates, shop.DefaultDomainIn(i.DefaultDomainIn...))
	}
	if len(i.DefaultDomainNotIn) > 0 {
		predicates = append(predicates, shop.DefaultDomainNotIn(i.DefaultDomainNotIn...))
	}
	if i.DefaultDomainGT != nil {
		predicates = append(predicates, shop.DefaultDomainGT(*i.DefaultDomainGT))
	}
	if i.DefaultDomainGTE != nil {
		predicates = append(predicates, shop.DefaultDomainGTE(*i.DefaultDomainGTE))
	}
	if i.DefaultDomainLT != nil {
		predicates = append(predicates, shop.DefaultDomainLT(*i.DefaultDomainLT))
	}
	if i.DefaultDomainLTE != nil {
		predicates = append(predicates, shop.DefaultDomainLTE(*i.DefaultDomainLTE))
	}
	if i.DefaultDomainContains != nil {
		predicates = append(predicates, shop.DefaultDomainContains(*i.DefaultDomainContains))
	}
	if i.DefaultDomainHasPrefix != nil {
		predicates = append(predicates, shop.DefaultDomainHasPrefix(*i.DefaultDomainHasPrefix))
	}
	if i.DefaultDomainHasSuffix != nil {
		predicates = append(predicates, shop.DefaultDomainHasSuffix(*i.DefaultDomainHasSuffix))
	}
	if i.DefaultDomainEqualFold != nil {
		predicates = append(predicates, shop.DefaultDomainEqualFold(*i.DefaultDomainEqualFold))
	}
	if i.DefaultDomainContainsFold != nil {
		predicates = append(predicates, shop.DefaultDomainContainsFold(*i.DefaultDomainContainsFold))
	}
	if i.CustomDomain != nil {
		predicates = append(predicates, shop.CustomDomainEQ(*i.CustomDomain))
	}
	if i.CustomDomainNEQ != nil {
		predicates = append(predicates, shop.CustomDomainNEQ(*i.CustomDomainNEQ))
	}
	if len(i.CustomDomainIn) > 0 {
		predicates = append(predicates, shop.CustomDomainIn(i.CustomDomainIn...))
	}
	if len(i.CustomDomainNotIn) > 0 {
		predicates = append(predicates, shop.CustomDomainNotIn(i.CustomDomainNotIn...))
	}
	if i.CustomDomainGT != nil {
		predicates = append(predicates, shop.CustomDomainGT(*i.CustomDomainGT))
	}
	if i.CustomDomainGTE != nil {
		predicates = append(predicates, shop.CustomDomainGTE(*i.CustomDomainGTE))
	}
	if i.CustomDomainLT != nil {
		predicates = append(predicates, shop.CustomDomainLT(*i.CustomDomainLT))
	}
	if i.CustomDomainLTE != nil {
		predicates = append(predicates, shop.CustomDomainLTE(*i.CustomDomainLTE))
	}
	if i.CustomDomainContains != nil {
		predicates = append(predicates, shop.CustomDomainContains(*i.CustomDomainContains))
	}
	if i.CustomDomainHasPrefix != nil {
		predicates = append(predicates, shop.CustomDomainHasPrefix(*i.CustomDomainHasPrefix))
	}
	if i.CustomDomainHasSuffix != nil {
		predicates = append(predicates, shop.CustomDomainHasSuffix(*i.CustomDomainHasSuffix))
	}
	if i.CustomDomainEqualFold != nil {
		predicates = append(predicates, shop.CustomDomainEqualFold(*i.CustomDomainEqualFold))
	}
	if i.CustomDomainContainsFold != nil {
		predicates = append(predicates, shop.CustomDomainContainsFold(*i.CustomDomainContainsFold))
	}

	if i.HasThemes != nil {
		p := shop.HasThemes()
		if !*i.HasThemes {
			p = shop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThemesWith) > 0 {
		with := make([]predicate.Theme, 0, len(i.HasThemesWith))
		for _, w := range i.HasThemesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, shop.HasThemesWith(with...))
	}
	if i.HasThemeTemplates != nil {
		p := shop.HasThemeTemplates()
		if !*i.HasThemeTemplates {
			p = shop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThemeTemplatesWith) > 0 {
		with := make([]predicate.ThemeTemplate, 0, len(i.HasThemeTemplatesWith))
		for _, w := range i.HasThemeTemplatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, shop.HasThemeTemplatesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate ShopWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return shop.And(predicates...), nil
	}
}

// TemplateSectionWhereInput represents a where input for filtering TemplateSection queries.
type TemplateSectionWhereInput struct {
	Not *TemplateSectionWhereInput   `json:"not,omitempty"`
	Or  []*TemplateSectionWhereInput `json:"or,omitempty"`
	And []*TemplateSectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "cid" field predicates.
	Cid             *string  `json:"cid,omitempty"`
	CidNEQ          *string  `json:"cidNEQ,omitempty"`
	CidIn           []string `json:"cidIn,omitempty"`
	CidNotIn        []string `json:"cidNotIn,omitempty"`
	CidGT           *string  `json:"cidGT,omitempty"`
	CidGTE          *string  `json:"cidGTE,omitempty"`
	CidLT           *string  `json:"cidLT,omitempty"`
	CidLTE          *string  `json:"cidLTE,omitempty"`
	CidContains     *string  `json:"cidContains,omitempty"`
	CidHasPrefix    *string  `json:"cidHasPrefix,omitempty"`
	CidHasSuffix    *string  `json:"cidHasSuffix,omitempty"`
	CidEqualFold    *string  `json:"cidEqualFold,omitempty"`
	CidContainsFold *string  `json:"cidContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "area" field predicates.
	Area      *templatesection.Area  `json:"area,omitempty"`
	AreaNEQ   *templatesection.Area  `json:"areaNEQ,omitempty"`
	AreaIn    []templatesection.Area `json:"areaIn,omitempty"`
	AreaNotIn []templatesection.Area `json:"areaNotIn,omitempty"`

	// "component" field predicates.
	Component             *string  `json:"component,omitempty"`
	ComponentNEQ          *string  `json:"componentNEQ,omitempty"`
	ComponentIn           []string `json:"componentIn,omitempty"`
	ComponentNotIn        []string `json:"componentNotIn,omitempty"`
	ComponentGT           *string  `json:"componentGT,omitempty"`
	ComponentGTE          *string  `json:"componentGTE,omitempty"`
	ComponentLT           *string  `json:"componentLT,omitempty"`
	ComponentLTE          *string  `json:"componentLTE,omitempty"`
	ComponentContains     *string  `json:"componentContains,omitempty"`
	ComponentHasPrefix    *string  `json:"componentHasPrefix,omitempty"`
	ComponentHasSuffix    *string  `json:"componentHasSuffix,omitempty"`
	ComponentEqualFold    *string  `json:"componentEqualFold,omitempty"`
	ComponentContainsFold *string  `json:"componentContainsFold,omitempty"`

	// "position" field predicates.
	Position      *int  `json:"position,omitempty"`
	PositionNEQ   *int  `json:"positionNEQ,omitempty"`
	PositionIn    []int `json:"positionIn,omitempty"`
	PositionNotIn []int `json:"positionNotIn,omitempty"`
	PositionGT    *int  `json:"positionGT,omitempty"`
	PositionGTE   *int  `json:"positionGTE,omitempty"`
	PositionLT    *int  `json:"positionLT,omitempty"`
	PositionLTE   *int  `json:"positionLTE,omitempty"`

	// "display" field predicates.
	Display    *bool `json:"display,omitempty"`
	DisplayNEQ *bool `json:"displayNEQ,omitempty"`

	// "revisions" edge predicates.
	HasRevisions     *bool                          `json:"hasRevisions,omitempty"`
	HasRevisionsWith []*BkTemplateSectionWhereInput `json:"hasRevisionsWith,omitempty"`
}

// Filter applies the TemplateSectionWhereInput filter on the TemplateSectionQuery builder.
func (i *TemplateSectionWhereInput) Filter(q *TemplateSectionQuery) (*TemplateSectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering templatesections.
// An error is returned if the input is empty or invalid.
func (i *TemplateSectionWhereInput) P() (predicate.TemplateSection, error) {
	var predicates []predicate.TemplateSection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, templatesection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TemplateSection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, templatesection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TemplateSection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, templatesection.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, templatesection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, templatesection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, templatesection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, templatesection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, templatesection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, templatesection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, templatesection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, templatesection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, templatesection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, templatesection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, templatesection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, templatesection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, templatesection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, templatesection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, templatesection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, templatesection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, templatesection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, templatesection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, templatesection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, templatesection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, templatesection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, templatesection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, templatesection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, templatesection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, templatesection.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, templatesection.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, templatesection.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, templatesection.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, templatesection.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, templatesection.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, templatesection.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, templatesection.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, templatesection.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, templatesection.DeletedAtNotNil())
	}
	if i.Cid != nil {
		predicates = append(predicates, templatesection.CidEQ(*i.Cid))
	}
	if i.CidNEQ != nil {
		predicates = append(predicates, templatesection.CidNEQ(*i.CidNEQ))
	}
	if len(i.CidIn) > 0 {
		predicates = append(predicates, templatesection.CidIn(i.CidIn...))
	}
	if len(i.CidNotIn) > 0 {
		predicates = append(predicates, templatesection.CidNotIn(i.CidNotIn...))
	}
	if i.CidGT != nil {
		predicates = append(predicates, templatesection.CidGT(*i.CidGT))
	}
	if i.CidGTE != nil {
		predicates = append(predicates, templatesection.CidGTE(*i.CidGTE))
	}
	if i.CidLT != nil {
		predicates = append(predicates, templatesection.CidLT(*i.CidLT))
	}
	if i.CidLTE != nil {
		predicates = append(predicates, templatesection.CidLTE(*i.CidLTE))
	}
	if i.CidContains != nil {
		predicates = append(predicates, templatesection.CidContains(*i.CidContains))
	}
	if i.CidHasPrefix != nil {
		predicates = append(predicates, templatesection.CidHasPrefix(*i.CidHasPrefix))
	}
	if i.CidHasSuffix != nil {
		predicates = append(predicates, templatesection.CidHasSuffix(*i.CidHasSuffix))
	}
	if i.CidEqualFold != nil {
		predicates = append(predicates, templatesection.CidEqualFold(*i.CidEqualFold))
	}
	if i.CidContainsFold != nil {
		predicates = append(predicates, templatesection.CidContainsFold(*i.CidContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, templatesection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, templatesection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, templatesection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, templatesection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, templatesection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, templatesection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, templatesection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, templatesection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, templatesection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, templatesection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, templatesection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, templatesection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, templatesection.NameContainsFold(*i.NameContainsFold))
	}
	if i.Area != nil {
		predicates = append(predicates, templatesection.AreaEQ(*i.Area))
	}
	if i.AreaNEQ != nil {
		predicates = append(predicates, templatesection.AreaNEQ(*i.AreaNEQ))
	}
	if len(i.AreaIn) > 0 {
		predicates = append(predicates, templatesection.AreaIn(i.AreaIn...))
	}
	if len(i.AreaNotIn) > 0 {
		predicates = append(predicates, templatesection.AreaNotIn(i.AreaNotIn...))
	}
	if i.Component != nil {
		predicates = append(predicates, templatesection.ComponentEQ(*i.Component))
	}
	if i.ComponentNEQ != nil {
		predicates = append(predicates, templatesection.ComponentNEQ(*i.ComponentNEQ))
	}
	if len(i.ComponentIn) > 0 {
		predicates = append(predicates, templatesection.ComponentIn(i.ComponentIn...))
	}
	if len(i.ComponentNotIn) > 0 {
		predicates = append(predicates, templatesection.ComponentNotIn(i.ComponentNotIn...))
	}
	if i.ComponentGT != nil {
		predicates = append(predicates, templatesection.ComponentGT(*i.ComponentGT))
	}
	if i.ComponentGTE != nil {
		predicates = append(predicates, templatesection.ComponentGTE(*i.ComponentGTE))
	}
	if i.ComponentLT != nil {
		predicates = append(predicates, templatesection.ComponentLT(*i.ComponentLT))
	}
	if i.ComponentLTE != nil {
		predicates = append(predicates, templatesection.ComponentLTE(*i.ComponentLTE))
	}
	if i.ComponentContains != nil {
		predicates = append(predicates, templatesection.ComponentContains(*i.ComponentContains))
	}
	if i.ComponentHasPrefix != nil {
		predicates = append(predicates, templatesection.ComponentHasPrefix(*i.ComponentHasPrefix))
	}
	if i.ComponentHasSuffix != nil {
		predicates = append(predicates, templatesection.ComponentHasSuffix(*i.ComponentHasSuffix))
	}
	if i.ComponentEqualFold != nil {
		predicates = append(predicates, templatesection.ComponentEqualFold(*i.ComponentEqualFold))
	}
	if i.ComponentContainsFold != nil {
		predicates = append(predicates, templatesection.ComponentContainsFold(*i.ComponentContainsFold))
	}
	if i.Position != nil {
		predicates = append(predicates, templatesection.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, templatesection.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, templatesection.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, templatesection.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, templatesection.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, templatesection.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, templatesection.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, templatesection.PositionLTE(*i.PositionLTE))
	}
	if i.Display != nil {
		predicates = append(predicates, templatesection.DisplayEQ(*i.Display))
	}
	if i.DisplayNEQ != nil {
		predicates = append(predicates, templatesection.DisplayNEQ(*i.DisplayNEQ))
	}

	if i.HasRevisions != nil {
		p := templatesection.HasRevisions()
		if !*i.HasRevisions {
			p = templatesection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRevisionsWith) > 0 {
		with := make([]predicate.BkTemplateSection, 0, len(i.HasRevisionsWith))
		for _, w := range i.HasRevisionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, templatesection.HasRevisionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate TemplateSectionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return templatesection.And(predicates...), nil
	}
}

// TemplateSectionVersionWhereInput represents a where input for filtering TemplateSectionVersion queries.
type TemplateSectionVersionWhereInput struct {
	Not *TemplateSectionVersionWhereInput   `json:"not,omitempty"`
	Or  []*TemplateSectionVersionWhereInput `json:"or,omitempty"`
	And []*TemplateSectionVersionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "bkTemplateSections" edge predicates.
	HasBkTemplateSections     *bool                          `json:"hasBkTemplateSections,omitempty"`
	HasBkTemplateSectionsWith []*BkTemplateSectionWhereInput `json:"hasBkTemplateSectionsWith,omitempty"`
}

// Filter applies the TemplateSectionVersionWhereInput filter on the TemplateSectionVersionQuery builder.
func (i *TemplateSectionVersionWhereInput) Filter(q *TemplateSectionVersionQuery) (*TemplateSectionVersionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering templatesectionversions.
// An error is returned if the input is empty or invalid.
func (i *TemplateSectionVersionWhereInput) P() (predicate.TemplateSectionVersion, error) {
	var predicates []predicate.TemplateSectionVersion
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, templatesectionversion.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TemplateSectionVersion, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, templatesectionversion.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TemplateSectionVersion, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, templatesectionversion.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, templatesectionversion.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, templatesectionversion.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, templatesectionversion.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, templatesectionversion.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, templatesectionversion.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, templatesectionversion.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, templatesectionversion.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, templatesectionversion.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, templatesectionversion.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, templatesectionversion.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, templatesectionversion.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, templatesectionversion.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, templatesectionversion.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, templatesectionversion.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Version != nil {
		predicates = append(predicates, templatesectionversion.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, templatesectionversion.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, templatesectionversion.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, templatesectionversion.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, templatesectionversion.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, templatesectionversion.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, templatesectionversion.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, templatesectionversion.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, templatesectionversion.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, templatesectionversion.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, templatesectionversion.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, templatesectionversion.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, templatesectionversion.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, templatesectionversion.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, templatesectionversion.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, templatesectionversion.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, templatesectionversion.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, templatesectionversion.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, templatesectionversion.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, templatesectionversion.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, templatesectionversion.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, templatesectionversion.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, templatesectionversion.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, templatesectionversion.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, templatesectionversion.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, templatesectionversion.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasBkTemplateSections != nil {
		p := templatesectionversion.HasBkTemplateSections()
		if !*i.HasBkTemplateSections {
			p = templatesectionversion.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBkTemplateSectionsWith) > 0 {
		with := make([]predicate.BkTemplateSection, 0, len(i.HasBkTemplateSectionsWith))
		for _, w := range i.HasBkTemplateSectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, templatesectionversion.HasBkTemplateSectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate TemplateSectionVersionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return templatesectionversion.And(predicates...), nil
	}
}

// ThemeWhereInput represents a where input for filtering Theme queries.
type ThemeWhereInput struct {
	Not *ThemeWhereInput   `json:"not,omitempty"`
	Or  []*ThemeWhereInput `json:"or,omitempty"`
	And []*ThemeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "thumbnail" field predicates.
	Thumbnail             *string  `json:"thumbnail,omitempty"`
	ThumbnailNEQ          *string  `json:"thumbnailNEQ,omitempty"`
	ThumbnailIn           []string `json:"thumbnailIn,omitempty"`
	ThumbnailNotIn        []string `json:"thumbnailNotIn,omitempty"`
	ThumbnailGT           *string  `json:"thumbnailGT,omitempty"`
	ThumbnailGTE          *string  `json:"thumbnailGTE,omitempty"`
	ThumbnailLT           *string  `json:"thumbnailLT,omitempty"`
	ThumbnailLTE          *string  `json:"thumbnailLTE,omitempty"`
	ThumbnailContains     *string  `json:"thumbnailContains,omitempty"`
	ThumbnailHasPrefix    *string  `json:"thumbnailHasPrefix,omitempty"`
	ThumbnailHasSuffix    *string  `json:"thumbnailHasSuffix,omitempty"`
	ThumbnailEqualFold    *string  `json:"thumbnailEqualFold,omitempty"`
	ThumbnailContainsFold *string  `json:"thumbnailContainsFold,omitempty"`

	// "publish" field predicates.
	Publish    *bool `json:"publish,omitempty"`
	PublishNEQ *bool `json:"publishNEQ,omitempty"`

	// "themeTemplates" edge predicates.
	HasThemeTemplates     *bool                      `json:"hasThemeTemplates,omitempty"`
	HasThemeTemplatesWith []*ThemeTemplateWhereInput `json:"hasThemeTemplatesWith,omitempty"`

	// "shop" edge predicates.
	HasShop     *bool             `json:"hasShop,omitempty"`
	HasShopWith []*ShopWhereInput `json:"hasShopWith,omitempty"`
}

// Filter applies the ThemeWhereInput filter on the ThemeQuery builder.
func (i *ThemeWhereInput) Filter(q *ThemeQuery) (*ThemeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering themes.
// An error is returned if the input is empty or invalid.
func (i *ThemeWhereInput) P() (predicate.Theme, error) {
	var predicates []predicate.Theme
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, theme.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Theme, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, theme.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Theme, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, theme.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, theme.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, theme.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, theme.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, theme.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, theme.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, theme.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, theme.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, theme.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, theme.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, theme.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, theme.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, theme.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, theme.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, theme.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, theme.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, theme.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, theme.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, theme.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, theme.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, theme.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, theme.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, theme.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, theme.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, theme.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, theme.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, theme.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, theme.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, theme.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, theme.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, theme.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, theme.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, theme.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, theme.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, theme.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, theme.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, theme.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, theme.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, theme.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, theme.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, theme.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, theme.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, theme.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, theme.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, theme.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, theme.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, theme.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, theme.NameContainsFold(*i.NameContainsFold))
	}
	if i.Thumbnail != nil {
		predicates = append(predicates, theme.ThumbnailEQ(*i.Thumbnail))
	}
	if i.ThumbnailNEQ != nil {
		predicates = append(predicates, theme.ThumbnailNEQ(*i.ThumbnailNEQ))
	}
	if len(i.ThumbnailIn) > 0 {
		predicates = append(predicates, theme.ThumbnailIn(i.ThumbnailIn...))
	}
	if len(i.ThumbnailNotIn) > 0 {
		predicates = append(predicates, theme.ThumbnailNotIn(i.ThumbnailNotIn...))
	}
	if i.ThumbnailGT != nil {
		predicates = append(predicates, theme.ThumbnailGT(*i.ThumbnailGT))
	}
	if i.ThumbnailGTE != nil {
		predicates = append(predicates, theme.ThumbnailGTE(*i.ThumbnailGTE))
	}
	if i.ThumbnailLT != nil {
		predicates = append(predicates, theme.ThumbnailLT(*i.ThumbnailLT))
	}
	if i.ThumbnailLTE != nil {
		predicates = append(predicates, theme.ThumbnailLTE(*i.ThumbnailLTE))
	}
	if i.ThumbnailContains != nil {
		predicates = append(predicates, theme.ThumbnailContains(*i.ThumbnailContains))
	}
	if i.ThumbnailHasPrefix != nil {
		predicates = append(predicates, theme.ThumbnailHasPrefix(*i.ThumbnailHasPrefix))
	}
	if i.ThumbnailHasSuffix != nil {
		predicates = append(predicates, theme.ThumbnailHasSuffix(*i.ThumbnailHasSuffix))
	}
	if i.ThumbnailEqualFold != nil {
		predicates = append(predicates, theme.ThumbnailEqualFold(*i.ThumbnailEqualFold))
	}
	if i.ThumbnailContainsFold != nil {
		predicates = append(predicates, theme.ThumbnailContainsFold(*i.ThumbnailContainsFold))
	}
	if i.Publish != nil {
		predicates = append(predicates, theme.PublishEQ(*i.Publish))
	}
	if i.PublishNEQ != nil {
		predicates = append(predicates, theme.PublishNEQ(*i.PublishNEQ))
	}

	if i.HasThemeTemplates != nil {
		p := theme.HasThemeTemplates()
		if !*i.HasThemeTemplates {
			p = theme.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThemeTemplatesWith) > 0 {
		with := make([]predicate.ThemeTemplate, 0, len(i.HasThemeTemplatesWith))
		for _, w := range i.HasThemeTemplatesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, theme.HasThemeTemplatesWith(with...))
	}
	if i.HasShop != nil {
		p := theme.HasShop()
		if !*i.HasShop {
			p = theme.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShopWith) > 0 {
		with := make([]predicate.Shop, 0, len(i.HasShopWith))
		for _, w := range i.HasShopWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, theme.HasShopWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate ThemeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return theme.And(predicates...), nil
	}
}

// ThemeTemplateWhereInput represents a where input for filtering ThemeTemplate queries.
type ThemeTemplateWhereInput struct {
	Not *ThemeTemplateWhereInput   `json:"not,omitempty"`
	Or  []*ThemeTemplateWhereInput `json:"or,omitempty"`
	And []*ThemeTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "page_type" field predicates.
	PageType      *themetemplate.PageType  `json:"pageType,omitempty"`
	PageTypeNEQ   *themetemplate.PageType  `json:"pageTypeNEQ,omitempty"`
	PageTypeIn    []themetemplate.PageType `json:"pageTypeIn,omitempty"`
	PageTypeNotIn []themetemplate.PageType `json:"pageTypeNotIn,omitempty"`

	// "default" field predicates.
	Default    *bool `json:"default,omitempty"`
	DefaultNEQ *bool `json:"defaultNEQ,omitempty"`

	// "shop" edge predicates.
	HasShop     *bool             `json:"hasShop,omitempty"`
	HasShopWith []*ShopWhereInput `json:"hasShopWith,omitempty"`

	// "theme" edge predicates.
	HasTheme     *bool              `json:"hasTheme,omitempty"`
	HasThemeWith []*ThemeWhereInput `json:"hasThemeWith,omitempty"`
}

// Filter applies the ThemeTemplateWhereInput filter on the ThemeTemplateQuery builder.
func (i *ThemeTemplateWhereInput) Filter(q *ThemeTemplateQuery) (*ThemeTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering themetemplates.
// An error is returned if the input is empty or invalid.
func (i *ThemeTemplateWhereInput) P() (predicate.ThemeTemplate, error) {
	var predicates []predicate.ThemeTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, themetemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ThemeTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, themetemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ThemeTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, themetemplate.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, themetemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, themetemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, themetemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, themetemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, themetemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, themetemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, themetemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, themetemplate.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, themetemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, themetemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, themetemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, themetemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, themetemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, themetemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, themetemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, themetemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, themetemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, themetemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, themetemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, themetemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, themetemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, themetemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, themetemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, themetemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, themetemplate.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, themetemplate.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, themetemplate.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, themetemplate.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, themetemplate.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, themetemplate.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, themetemplate.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, themetemplate.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, themetemplate.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, themetemplate.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, themetemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, themetemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, themetemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, themetemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, themetemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, themetemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, themetemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, themetemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, themetemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, themetemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, themetemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, themetemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, themetemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.PageType != nil {
		predicates = append(predicates, themetemplate.PageTypeEQ(*i.PageType))
	}
	if i.PageTypeNEQ != nil {
		predicates = append(predicates, themetemplate.PageTypeNEQ(*i.PageTypeNEQ))
	}
	if len(i.PageTypeIn) > 0 {
		predicates = append(predicates, themetemplate.PageTypeIn(i.PageTypeIn...))
	}
	if len(i.PageTypeNotIn) > 0 {
		predicates = append(predicates, themetemplate.PageTypeNotIn(i.PageTypeNotIn...))
	}
	if i.Default != nil {
		predicates = append(predicates, themetemplate.DefaultEQ(*i.Default))
	}
	if i.DefaultNEQ != nil {
		predicates = append(predicates, themetemplate.DefaultNEQ(*i.DefaultNEQ))
	}

	if i.HasShop != nil {
		p := themetemplate.HasShop()
		if !*i.HasShop {
			p = themetemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShopWith) > 0 {
		with := make([]predicate.Shop, 0, len(i.HasShopWith))
		for _, w := range i.HasShopWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, themetemplate.HasShopWith(with...))
	}
	if i.HasTheme != nil {
		p := themetemplate.HasTheme()
		if !*i.HasTheme {
			p = themetemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThemeWith) > 0 {
		with := make([]predicate.Theme, 0, len(i.HasThemeWith))
		for _, w := range i.HasThemeWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, themetemplate.HasThemeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate ThemeTemplateWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return themetemplate.And(predicates...), nil
	}
}

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Not *TodoWhereInput   `json:"not,omitempty"`
	Or  []*TodoWhereInput `json:"or,omitempty"`
	And []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uint64  `json:"id,omitempty"`
	IDNEQ   *uint64  `json:"idNEQ,omitempty"`
	IDIn    []uint64 `json:"idIn,omitempty"`
	IDNotIn []uint64 `json:"idNotIn,omitempty"`
	IDGT    *uint64  `json:"idGT,omitempty"`
	IDGTE   *uint64  `json:"idGTE,omitempty"`
	IDLT    *uint64  `json:"idLT,omitempty"`
	IDLTE   *uint64  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool             `json:"hasChildren,omitempty"`
	HasChildrenWith []*TodoWhereInput `json:"hasChildrenWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*TodoWhereInput `json:"hasParentWith,omitempty"`
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, todo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, todo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, todo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, todo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, todo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, todo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, todo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, todo.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, todo.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, todo.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, todo.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, todo.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, todo.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, todo.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, todo.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, todo.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, todo.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, todo.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, todo.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, todo.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, todo.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, todo.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, todo.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, todo.DeletedAtNotNil())
	}
	if i.Text != nil {
		predicates = append(predicates, todo.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, todo.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, todo.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, todo.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, todo.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, todo.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, todo.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, todo.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, todo.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, todo.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, todo.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, todo.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, todo.TextContainsFold(*i.TextContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, todo.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, todo.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, todo.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, todo.StatusNotIn(i.StatusNotIn...))
	}
	if i.Priority != nil {
		predicates = append(predicates, todo.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, todo.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, todo.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, todo.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, todo.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, todo.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, todo.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, todo.PriorityLTE(*i.PriorityLTE))
	}

	if i.HasChildren != nil {
		p := todo.HasChildren()
		if !*i.HasChildren {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasChildrenWith(with...))
	}
	if i.HasParent != nil {
		p := todo.HasParent()
		if !*i.HasParent {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasParentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("app-api/ent: empty predicate TodoWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}

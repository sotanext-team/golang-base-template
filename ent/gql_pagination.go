// Code generated by entc, DO NOT EDIT.

package ent

import (
	"app-api/ent/bktemplatesection"
	"app-api/ent/componentproperty"
	"app-api/ent/customcomponent"
	"app-api/ent/globaltemplate"
	"app-api/ent/shop"
	"app-api/ent/templatesection"
	"app-api/ent/templatesectionversion"
	"app-api/ent/theme"
	"app-api/ent/themetemplate"
	"app-api/ent/todo"
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uint64 `msgpack:"i"`
	Value Value  `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// BkTemplateSectionEdge is the edge representation of BkTemplateSection.
type BkTemplateSectionEdge struct {
	Node   *BkTemplateSection `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// BkTemplateSectionConnection is the connection containing edges to BkTemplateSection.
type BkTemplateSectionConnection struct {
	Edges      []*BkTemplateSectionEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// BkTemplateSectionPaginateOption enables pagination customization.
type BkTemplateSectionPaginateOption func(*bkTemplateSectionPager) error

// WithBkTemplateSectionOrder configures pagination ordering.
func WithBkTemplateSectionOrder(order *BkTemplateSectionOrder) BkTemplateSectionPaginateOption {
	if order == nil {
		order = DefaultBkTemplateSectionOrder
	}
	o := *order
	return func(pager *bkTemplateSectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBkTemplateSectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBkTemplateSectionFilter configures pagination filter.
func WithBkTemplateSectionFilter(filter func(*BkTemplateSectionQuery) (*BkTemplateSectionQuery, error)) BkTemplateSectionPaginateOption {
	return func(pager *bkTemplateSectionPager) error {
		if filter == nil {
			return errors.New("BkTemplateSectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bkTemplateSectionPager struct {
	order  *BkTemplateSectionOrder
	filter func(*BkTemplateSectionQuery) (*BkTemplateSectionQuery, error)
}

func newBkTemplateSectionPager(opts []BkTemplateSectionPaginateOption) (*bkTemplateSectionPager, error) {
	pager := &bkTemplateSectionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBkTemplateSectionOrder
	}
	return pager, nil
}

func (p *bkTemplateSectionPager) applyFilter(query *BkTemplateSectionQuery) (*BkTemplateSectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bkTemplateSectionPager) toCursor(bts *BkTemplateSection) Cursor {
	return p.order.Field.toCursor(bts)
}

func (p *bkTemplateSectionPager) applyCursors(query *BkTemplateSectionQuery, after, before *Cursor) *BkTemplateSectionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBkTemplateSectionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *bkTemplateSectionPager) applyOrder(query *BkTemplateSectionQuery, reverse bool) *BkTemplateSectionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBkTemplateSectionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBkTemplateSectionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to BkTemplateSection.
func (bts *BkTemplateSectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BkTemplateSectionPaginateOption,
) (*BkTemplateSectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBkTemplateSectionPager(opts)
	if err != nil {
		return nil, err
	}

	if bts, err = pager.applyFilter(bts); err != nil {
		return nil, err
	}

	conn := &BkTemplateSectionConnection{Edges: []*BkTemplateSectionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := bts.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := bts.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	bts = pager.applyCursors(bts, after, before)
	bts = pager.applyOrder(bts, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		bts = bts.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		bts = bts.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := bts.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *BkTemplateSection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BkTemplateSection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BkTemplateSection {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BkTemplateSectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BkTemplateSectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// BkTemplateSectionOrderFieldCreatedAt orders BkTemplateSection by created_at.
	BkTemplateSectionOrderFieldCreatedAt = &BkTemplateSectionOrderField{
		field: bktemplatesection.FieldCreatedAt,
		toCursor: func(bts *BkTemplateSection) Cursor {
			return Cursor{
				ID:    bts.ID,
				Value: bts.CreatedAt,
			}
		},
	}
	// BkTemplateSectionOrderFieldUpdatedAt orders BkTemplateSection by updated_at.
	BkTemplateSectionOrderFieldUpdatedAt = &BkTemplateSectionOrderField{
		field: bktemplatesection.FieldUpdatedAt,
		toCursor: func(bts *BkTemplateSection) Cursor {
			return Cursor{
				ID:    bts.ID,
				Value: bts.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BkTemplateSectionOrderField) String() string {
	var str string
	switch f.field {
	case bktemplatesection.FieldCreatedAt:
		str = "CREATED_AT"
	case bktemplatesection.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BkTemplateSectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BkTemplateSectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BkTemplateSectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BkTemplateSectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BkTemplateSectionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid BkTemplateSectionOrderField", str)
	}
	return nil
}

// BkTemplateSectionOrderField defines the ordering field of BkTemplateSection.
type BkTemplateSectionOrderField struct {
	field    string
	toCursor func(*BkTemplateSection) Cursor
}

// BkTemplateSectionOrder defines the ordering of BkTemplateSection.
type BkTemplateSectionOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *BkTemplateSectionOrderField `json:"field"`
}

// DefaultBkTemplateSectionOrder is the default ordering of BkTemplateSection.
var DefaultBkTemplateSectionOrder = &BkTemplateSectionOrder{
	Direction: OrderDirectionAsc,
	Field: &BkTemplateSectionOrderField{
		field: bktemplatesection.FieldID,
		toCursor: func(bts *BkTemplateSection) Cursor {
			return Cursor{ID: bts.ID}
		},
	},
}

// ToEdge converts BkTemplateSection into BkTemplateSectionEdge.
func (bts *BkTemplateSection) ToEdge(order *BkTemplateSectionOrder) *BkTemplateSectionEdge {
	if order == nil {
		order = DefaultBkTemplateSectionOrder
	}
	return &BkTemplateSectionEdge{
		Node:   bts,
		Cursor: order.Field.toCursor(bts),
	}
}

// ComponentPropertyEdge is the edge representation of ComponentProperty.
type ComponentPropertyEdge struct {
	Node   *ComponentProperty `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ComponentPropertyConnection is the connection containing edges to ComponentProperty.
type ComponentPropertyConnection struct {
	Edges      []*ComponentPropertyEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// ComponentPropertyPaginateOption enables pagination customization.
type ComponentPropertyPaginateOption func(*componentPropertyPager) error

// WithComponentPropertyOrder configures pagination ordering.
func WithComponentPropertyOrder(order *ComponentPropertyOrder) ComponentPropertyPaginateOption {
	if order == nil {
		order = DefaultComponentPropertyOrder
	}
	o := *order
	return func(pager *componentPropertyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultComponentPropertyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithComponentPropertyFilter configures pagination filter.
func WithComponentPropertyFilter(filter func(*ComponentPropertyQuery) (*ComponentPropertyQuery, error)) ComponentPropertyPaginateOption {
	return func(pager *componentPropertyPager) error {
		if filter == nil {
			return errors.New("ComponentPropertyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type componentPropertyPager struct {
	order  *ComponentPropertyOrder
	filter func(*ComponentPropertyQuery) (*ComponentPropertyQuery, error)
}

func newComponentPropertyPager(opts []ComponentPropertyPaginateOption) (*componentPropertyPager, error) {
	pager := &componentPropertyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultComponentPropertyOrder
	}
	return pager, nil
}

func (p *componentPropertyPager) applyFilter(query *ComponentPropertyQuery) (*ComponentPropertyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *componentPropertyPager) toCursor(cp *ComponentProperty) Cursor {
	return p.order.Field.toCursor(cp)
}

func (p *componentPropertyPager) applyCursors(query *ComponentPropertyQuery, after, before *Cursor) *ComponentPropertyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultComponentPropertyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *componentPropertyPager) applyOrder(query *ComponentPropertyQuery, reverse bool) *ComponentPropertyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultComponentPropertyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultComponentPropertyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ComponentProperty.
func (cp *ComponentPropertyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ComponentPropertyPaginateOption,
) (*ComponentPropertyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newComponentPropertyPager(opts)
	if err != nil {
		return nil, err
	}

	if cp, err = pager.applyFilter(cp); err != nil {
		return nil, err
	}

	conn := &ComponentPropertyConnection{Edges: []*ComponentPropertyEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cp = pager.applyCursors(cp, after, before)
	cp = pager.applyOrder(cp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cp = cp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cp = cp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ComponentProperty
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ComponentProperty {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ComponentProperty {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ComponentPropertyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ComponentPropertyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ComponentPropertyOrderFieldCreatedAt orders ComponentProperty by created_at.
	ComponentPropertyOrderFieldCreatedAt = &ComponentPropertyOrderField{
		field: componentproperty.FieldCreatedAt,
		toCursor: func(cp *ComponentProperty) Cursor {
			return Cursor{
				ID:    cp.ID,
				Value: cp.CreatedAt,
			}
		},
	}
	// ComponentPropertyOrderFieldUpdatedAt orders ComponentProperty by updated_at.
	ComponentPropertyOrderFieldUpdatedAt = &ComponentPropertyOrderField{
		field: componentproperty.FieldUpdatedAt,
		toCursor: func(cp *ComponentProperty) Cursor {
			return Cursor{
				ID:    cp.ID,
				Value: cp.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ComponentPropertyOrderField) String() string {
	var str string
	switch f.field {
	case componentproperty.FieldCreatedAt:
		str = "CREATED_AT"
	case componentproperty.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ComponentPropertyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ComponentPropertyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ComponentPropertyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ComponentPropertyOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ComponentPropertyOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ComponentPropertyOrderField", str)
	}
	return nil
}

// ComponentPropertyOrderField defines the ordering field of ComponentProperty.
type ComponentPropertyOrderField struct {
	field    string
	toCursor func(*ComponentProperty) Cursor
}

// ComponentPropertyOrder defines the ordering of ComponentProperty.
type ComponentPropertyOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ComponentPropertyOrderField `json:"field"`
}

// DefaultComponentPropertyOrder is the default ordering of ComponentProperty.
var DefaultComponentPropertyOrder = &ComponentPropertyOrder{
	Direction: OrderDirectionAsc,
	Field: &ComponentPropertyOrderField{
		field: componentproperty.FieldID,
		toCursor: func(cp *ComponentProperty) Cursor {
			return Cursor{ID: cp.ID}
		},
	},
}

// ToEdge converts ComponentProperty into ComponentPropertyEdge.
func (cp *ComponentProperty) ToEdge(order *ComponentPropertyOrder) *ComponentPropertyEdge {
	if order == nil {
		order = DefaultComponentPropertyOrder
	}
	return &ComponentPropertyEdge{
		Node:   cp,
		Cursor: order.Field.toCursor(cp),
	}
}

// CustomComponentEdge is the edge representation of CustomComponent.
type CustomComponentEdge struct {
	Node   *CustomComponent `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CustomComponentConnection is the connection containing edges to CustomComponent.
type CustomComponentConnection struct {
	Edges      []*CustomComponentEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// CustomComponentPaginateOption enables pagination customization.
type CustomComponentPaginateOption func(*customComponentPager) error

// WithCustomComponentOrder configures pagination ordering.
func WithCustomComponentOrder(order *CustomComponentOrder) CustomComponentPaginateOption {
	if order == nil {
		order = DefaultCustomComponentOrder
	}
	o := *order
	return func(pager *customComponentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomComponentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomComponentFilter configures pagination filter.
func WithCustomComponentFilter(filter func(*CustomComponentQuery) (*CustomComponentQuery, error)) CustomComponentPaginateOption {
	return func(pager *customComponentPager) error {
		if filter == nil {
			return errors.New("CustomComponentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customComponentPager struct {
	order  *CustomComponentOrder
	filter func(*CustomComponentQuery) (*CustomComponentQuery, error)
}

func newCustomComponentPager(opts []CustomComponentPaginateOption) (*customComponentPager, error) {
	pager := &customComponentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomComponentOrder
	}
	return pager, nil
}

func (p *customComponentPager) applyFilter(query *CustomComponentQuery) (*CustomComponentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customComponentPager) toCursor(cc *CustomComponent) Cursor {
	return p.order.Field.toCursor(cc)
}

func (p *customComponentPager) applyCursors(query *CustomComponentQuery, after, before *Cursor) *CustomComponentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCustomComponentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *customComponentPager) applyOrder(query *CustomComponentQuery, reverse bool) *CustomComponentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCustomComponentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCustomComponentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CustomComponent.
func (cc *CustomComponentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomComponentPaginateOption,
) (*CustomComponentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomComponentPager(opts)
	if err != nil {
		return nil, err
	}

	if cc, err = pager.applyFilter(cc); err != nil {
		return nil, err
	}

	conn := &CustomComponentConnection{Edges: []*CustomComponentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cc = pager.applyCursors(cc, after, before)
	cc = pager.applyOrder(cc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cc = cc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cc = cc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CustomComponent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomComponent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomComponent {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CustomComponentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CustomComponentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CustomComponentOrderFieldCreatedAt orders CustomComponent by created_at.
	CustomComponentOrderFieldCreatedAt = &CustomComponentOrderField{
		field: customcomponent.FieldCreatedAt,
		toCursor: func(cc *CustomComponent) Cursor {
			return Cursor{
				ID:    cc.ID,
				Value: cc.CreatedAt,
			}
		},
	}
	// CustomComponentOrderFieldUpdatedAt orders CustomComponent by updated_at.
	CustomComponentOrderFieldUpdatedAt = &CustomComponentOrderField{
		field: customcomponent.FieldUpdatedAt,
		toCursor: func(cc *CustomComponent) Cursor {
			return Cursor{
				ID:    cc.ID,
				Value: cc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomComponentOrderField) String() string {
	var str string
	switch f.field {
	case customcomponent.FieldCreatedAt:
		str = "CREATED_AT"
	case customcomponent.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomComponentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomComponentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomComponentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CustomComponentOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CustomComponentOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid CustomComponentOrderField", str)
	}
	return nil
}

// CustomComponentOrderField defines the ordering field of CustomComponent.
type CustomComponentOrderField struct {
	field    string
	toCursor func(*CustomComponent) Cursor
}

// CustomComponentOrder defines the ordering of CustomComponent.
type CustomComponentOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CustomComponentOrderField `json:"field"`
}

// DefaultCustomComponentOrder is the default ordering of CustomComponent.
var DefaultCustomComponentOrder = &CustomComponentOrder{
	Direction: OrderDirectionAsc,
	Field: &CustomComponentOrderField{
		field: customcomponent.FieldID,
		toCursor: func(cc *CustomComponent) Cursor {
			return Cursor{ID: cc.ID}
		},
	},
}

// ToEdge converts CustomComponent into CustomComponentEdge.
func (cc *CustomComponent) ToEdge(order *CustomComponentOrder) *CustomComponentEdge {
	if order == nil {
		order = DefaultCustomComponentOrder
	}
	return &CustomComponentEdge{
		Node:   cc,
		Cursor: order.Field.toCursor(cc),
	}
}

// GlobalTemplateEdge is the edge representation of GlobalTemplate.
type GlobalTemplateEdge struct {
	Node   *GlobalTemplate `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// GlobalTemplateConnection is the connection containing edges to GlobalTemplate.
type GlobalTemplateConnection struct {
	Edges      []*GlobalTemplateEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// GlobalTemplatePaginateOption enables pagination customization.
type GlobalTemplatePaginateOption func(*globalTemplatePager) error

// WithGlobalTemplateOrder configures pagination ordering.
func WithGlobalTemplateOrder(order *GlobalTemplateOrder) GlobalTemplatePaginateOption {
	if order == nil {
		order = DefaultGlobalTemplateOrder
	}
	o := *order
	return func(pager *globalTemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGlobalTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGlobalTemplateFilter configures pagination filter.
func WithGlobalTemplateFilter(filter func(*GlobalTemplateQuery) (*GlobalTemplateQuery, error)) GlobalTemplatePaginateOption {
	return func(pager *globalTemplatePager) error {
		if filter == nil {
			return errors.New("GlobalTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type globalTemplatePager struct {
	order  *GlobalTemplateOrder
	filter func(*GlobalTemplateQuery) (*GlobalTemplateQuery, error)
}

func newGlobalTemplatePager(opts []GlobalTemplatePaginateOption) (*globalTemplatePager, error) {
	pager := &globalTemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGlobalTemplateOrder
	}
	return pager, nil
}

func (p *globalTemplatePager) applyFilter(query *GlobalTemplateQuery) (*GlobalTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *globalTemplatePager) toCursor(gt *GlobalTemplate) Cursor {
	return p.order.Field.toCursor(gt)
}

func (p *globalTemplatePager) applyCursors(query *GlobalTemplateQuery, after, before *Cursor) *GlobalTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultGlobalTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *globalTemplatePager) applyOrder(query *GlobalTemplateQuery, reverse bool) *GlobalTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultGlobalTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultGlobalTemplateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to GlobalTemplate.
func (gt *GlobalTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GlobalTemplatePaginateOption,
) (*GlobalTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGlobalTemplatePager(opts)
	if err != nil {
		return nil, err
	}

	if gt, err = pager.applyFilter(gt); err != nil {
		return nil, err
	}

	conn := &GlobalTemplateConnection{Edges: []*GlobalTemplateEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := gt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := gt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	gt = pager.applyCursors(gt, after, before)
	gt = pager.applyOrder(gt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		gt = gt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		gt = gt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := gt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *GlobalTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GlobalTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GlobalTemplate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*GlobalTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &GlobalTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// GlobalTemplateOrderFieldCreatedAt orders GlobalTemplate by created_at.
	GlobalTemplateOrderFieldCreatedAt = &GlobalTemplateOrderField{
		field: globaltemplate.FieldCreatedAt,
		toCursor: func(gt *GlobalTemplate) Cursor {
			return Cursor{
				ID:    gt.ID,
				Value: gt.CreatedAt,
			}
		},
	}
	// GlobalTemplateOrderFieldUpdatedAt orders GlobalTemplate by updated_at.
	GlobalTemplateOrderFieldUpdatedAt = &GlobalTemplateOrderField{
		field: globaltemplate.FieldUpdatedAt,
		toCursor: func(gt *GlobalTemplate) Cursor {
			return Cursor{
				ID:    gt.ID,
				Value: gt.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GlobalTemplateOrderField) String() string {
	var str string
	switch f.field {
	case globaltemplate.FieldCreatedAt:
		str = "CREATED_AT"
	case globaltemplate.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GlobalTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GlobalTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GlobalTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *GlobalTemplateOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *GlobalTemplateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GlobalTemplateOrderField", str)
	}
	return nil
}

// GlobalTemplateOrderField defines the ordering field of GlobalTemplate.
type GlobalTemplateOrderField struct {
	field    string
	toCursor func(*GlobalTemplate) Cursor
}

// GlobalTemplateOrder defines the ordering of GlobalTemplate.
type GlobalTemplateOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *GlobalTemplateOrderField `json:"field"`
}

// DefaultGlobalTemplateOrder is the default ordering of GlobalTemplate.
var DefaultGlobalTemplateOrder = &GlobalTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &GlobalTemplateOrderField{
		field: globaltemplate.FieldID,
		toCursor: func(gt *GlobalTemplate) Cursor {
			return Cursor{ID: gt.ID}
		},
	},
}

// ToEdge converts GlobalTemplate into GlobalTemplateEdge.
func (gt *GlobalTemplate) ToEdge(order *GlobalTemplateOrder) *GlobalTemplateEdge {
	if order == nil {
		order = DefaultGlobalTemplateOrder
	}
	return &GlobalTemplateEdge{
		Node:   gt,
		Cursor: order.Field.toCursor(gt),
	}
}

// ShopEdge is the edge representation of Shop.
type ShopEdge struct {
	Node   *Shop  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ShopConnection is the connection containing edges to Shop.
type ShopConnection struct {
	Edges      []*ShopEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// ShopPaginateOption enables pagination customization.
type ShopPaginateOption func(*shopPager) error

// WithShopOrder configures pagination ordering.
func WithShopOrder(order *ShopOrder) ShopPaginateOption {
	if order == nil {
		order = DefaultShopOrder
	}
	o := *order
	return func(pager *shopPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShopOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShopFilter configures pagination filter.
func WithShopFilter(filter func(*ShopQuery) (*ShopQuery, error)) ShopPaginateOption {
	return func(pager *shopPager) error {
		if filter == nil {
			return errors.New("ShopQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shopPager struct {
	order  *ShopOrder
	filter func(*ShopQuery) (*ShopQuery, error)
}

func newShopPager(opts []ShopPaginateOption) (*shopPager, error) {
	pager := &shopPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShopOrder
	}
	return pager, nil
}

func (p *shopPager) applyFilter(query *ShopQuery) (*ShopQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shopPager) toCursor(s *Shop) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *shopPager) applyCursors(query *ShopQuery, after, before *Cursor) *ShopQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultShopOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *shopPager) applyOrder(query *ShopQuery, reverse bool) *ShopQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultShopOrder.Field {
		query = query.Order(direction.orderFunc(DefaultShopOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Shop.
func (s *ShopQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShopPaginateOption,
) (*ShopConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShopPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ShopConnection{Edges: []*ShopEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Shop
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Shop {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Shop {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ShopEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ShopEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ShopOrderFieldCreatedAt orders Shop by created_at.
	ShopOrderFieldCreatedAt = &ShopOrderField{
		field: shop.FieldCreatedAt,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// ShopOrderFieldUpdatedAt orders Shop by updated_at.
	ShopOrderFieldUpdatedAt = &ShopOrderField{
		field: shop.FieldUpdatedAt,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// ShopOrderFieldShopName orders Shop by shop_name.
	ShopOrderFieldShopName = &ShopOrderField{
		field: shop.FieldShopName,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.ShopName,
			}
		},
	}
	// ShopOrderFieldDefaultDomain orders Shop by default_domain.
	ShopOrderFieldDefaultDomain = &ShopOrderField{
		field: shop.FieldDefaultDomain,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DefaultDomain,
			}
		},
	}
	// ShopOrderFieldCustomDomain orders Shop by custom_domain.
	ShopOrderFieldCustomDomain = &ShopOrderField{
		field: shop.FieldCustomDomain,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CustomDomain,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShopOrderField) String() string {
	var str string
	switch f.field {
	case shop.FieldCreatedAt:
		str = "CREATED_AT"
	case shop.FieldUpdatedAt:
		str = "UPDATED_AT"
	case shop.FieldShopName:
		str = "SHOP_NAME"
	case shop.FieldDefaultDomain:
		str = "DEFAULT_DOMAIN"
	case shop.FieldCustomDomain:
		str = "CUSTOM_DOMAIN"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShopOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShopOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShopOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ShopOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ShopOrderFieldUpdatedAt
	case "SHOP_NAME":
		*f = *ShopOrderFieldShopName
	case "DEFAULT_DOMAIN":
		*f = *ShopOrderFieldDefaultDomain
	case "CUSTOM_DOMAIN":
		*f = *ShopOrderFieldCustomDomain
	default:
		return fmt.Errorf("%s is not a valid ShopOrderField", str)
	}
	return nil
}

// ShopOrderField defines the ordering field of Shop.
type ShopOrderField struct {
	field    string
	toCursor func(*Shop) Cursor
}

// ShopOrder defines the ordering of Shop.
type ShopOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ShopOrderField `json:"field"`
}

// DefaultShopOrder is the default ordering of Shop.
var DefaultShopOrder = &ShopOrder{
	Direction: OrderDirectionAsc,
	Field: &ShopOrderField{
		field: shop.FieldID,
		toCursor: func(s *Shop) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Shop into ShopEdge.
func (s *Shop) ToEdge(order *ShopOrder) *ShopEdge {
	if order == nil {
		order = DefaultShopOrder
	}
	return &ShopEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TemplateSectionEdge is the edge representation of TemplateSection.
type TemplateSectionEdge struct {
	Node   *TemplateSection `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TemplateSectionConnection is the connection containing edges to TemplateSection.
type TemplateSectionConnection struct {
	Edges      []*TemplateSectionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// TemplateSectionPaginateOption enables pagination customization.
type TemplateSectionPaginateOption func(*templateSectionPager) error

// WithTemplateSectionOrder configures pagination ordering.
func WithTemplateSectionOrder(order *TemplateSectionOrder) TemplateSectionPaginateOption {
	if order == nil {
		order = DefaultTemplateSectionOrder
	}
	o := *order
	return func(pager *templateSectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateSectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateSectionFilter configures pagination filter.
func WithTemplateSectionFilter(filter func(*TemplateSectionQuery) (*TemplateSectionQuery, error)) TemplateSectionPaginateOption {
	return func(pager *templateSectionPager) error {
		if filter == nil {
			return errors.New("TemplateSectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templateSectionPager struct {
	order  *TemplateSectionOrder
	filter func(*TemplateSectionQuery) (*TemplateSectionQuery, error)
}

func newTemplateSectionPager(opts []TemplateSectionPaginateOption) (*templateSectionPager, error) {
	pager := &templateSectionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateSectionOrder
	}
	return pager, nil
}

func (p *templateSectionPager) applyFilter(query *TemplateSectionQuery) (*TemplateSectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templateSectionPager) toCursor(ts *TemplateSection) Cursor {
	return p.order.Field.toCursor(ts)
}

func (p *templateSectionPager) applyCursors(query *TemplateSectionQuery, after, before *Cursor) *TemplateSectionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTemplateSectionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *templateSectionPager) applyOrder(query *TemplateSectionQuery, reverse bool) *TemplateSectionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTemplateSectionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTemplateSectionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TemplateSection.
func (ts *TemplateSectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateSectionPaginateOption,
) (*TemplateSectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateSectionPager(opts)
	if err != nil {
		return nil, err
	}

	if ts, err = pager.applyFilter(ts); err != nil {
		return nil, err
	}

	conn := &TemplateSectionConnection{Edges: []*TemplateSectionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ts.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ts.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ts = pager.applyCursors(ts, after, before)
	ts = pager.applyOrder(ts, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ts = ts.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ts = ts.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ts.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TemplateSection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateSection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateSection {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TemplateSectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TemplateSectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TemplateSectionOrderFieldCreatedAt orders TemplateSection by created_at.
	TemplateSectionOrderFieldCreatedAt = &TemplateSectionOrderField{
		field: templatesection.FieldCreatedAt,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.CreatedAt,
			}
		},
	}
	// TemplateSectionOrderFieldUpdatedAt orders TemplateSection by updated_at.
	TemplateSectionOrderFieldUpdatedAt = &TemplateSectionOrderField{
		field: templatesection.FieldUpdatedAt,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.UpdatedAt,
			}
		},
	}
	// TemplateSectionOrderFieldName orders TemplateSection by name.
	TemplateSectionOrderFieldName = &TemplateSectionOrderField{
		field: templatesection.FieldName,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.Name,
			}
		},
	}
	// TemplateSectionOrderFieldArea orders TemplateSection by area.
	TemplateSectionOrderFieldArea = &TemplateSectionOrderField{
		field: templatesection.FieldArea,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.Area,
			}
		},
	}
	// TemplateSectionOrderFieldPosition orders TemplateSection by position.
	TemplateSectionOrderFieldPosition = &TemplateSectionOrderField{
		field: templatesection.FieldPosition,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.Position,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateSectionOrderField) String() string {
	var str string
	switch f.field {
	case templatesection.FieldCreatedAt:
		str = "CREATED_AT"
	case templatesection.FieldUpdatedAt:
		str = "UPDATED_AT"
	case templatesection.FieldName:
		str = "NAME"
	case templatesection.FieldArea:
		str = "AREA"
	case templatesection.FieldPosition:
		str = "POSITION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateSectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateSectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateSectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TemplateSectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TemplateSectionOrderFieldUpdatedAt
	case "NAME":
		*f = *TemplateSectionOrderFieldName
	case "AREA":
		*f = *TemplateSectionOrderFieldArea
	case "POSITION":
		*f = *TemplateSectionOrderFieldPosition
	default:
		return fmt.Errorf("%s is not a valid TemplateSectionOrderField", str)
	}
	return nil
}

// TemplateSectionOrderField defines the ordering field of TemplateSection.
type TemplateSectionOrderField struct {
	field    string
	toCursor func(*TemplateSection) Cursor
}

// TemplateSectionOrder defines the ordering of TemplateSection.
type TemplateSectionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TemplateSectionOrderField `json:"field"`
}

// DefaultTemplateSectionOrder is the default ordering of TemplateSection.
var DefaultTemplateSectionOrder = &TemplateSectionOrder{
	Direction: OrderDirectionAsc,
	Field: &TemplateSectionOrderField{
		field: templatesection.FieldID,
		toCursor: func(ts *TemplateSection) Cursor {
			return Cursor{ID: ts.ID}
		},
	},
}

// ToEdge converts TemplateSection into TemplateSectionEdge.
func (ts *TemplateSection) ToEdge(order *TemplateSectionOrder) *TemplateSectionEdge {
	if order == nil {
		order = DefaultTemplateSectionOrder
	}
	return &TemplateSectionEdge{
		Node:   ts,
		Cursor: order.Field.toCursor(ts),
	}
}

// TemplateSectionVersionEdge is the edge representation of TemplateSectionVersion.
type TemplateSectionVersionEdge struct {
	Node   *TemplateSectionVersion `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// TemplateSectionVersionConnection is the connection containing edges to TemplateSectionVersion.
type TemplateSectionVersionConnection struct {
	Edges      []*TemplateSectionVersionEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

// TemplateSectionVersionPaginateOption enables pagination customization.
type TemplateSectionVersionPaginateOption func(*templateSectionVersionPager) error

// WithTemplateSectionVersionOrder configures pagination ordering.
func WithTemplateSectionVersionOrder(order *TemplateSectionVersionOrder) TemplateSectionVersionPaginateOption {
	if order == nil {
		order = DefaultTemplateSectionVersionOrder
	}
	o := *order
	return func(pager *templateSectionVersionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateSectionVersionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateSectionVersionFilter configures pagination filter.
func WithTemplateSectionVersionFilter(filter func(*TemplateSectionVersionQuery) (*TemplateSectionVersionQuery, error)) TemplateSectionVersionPaginateOption {
	return func(pager *templateSectionVersionPager) error {
		if filter == nil {
			return errors.New("TemplateSectionVersionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templateSectionVersionPager struct {
	order  *TemplateSectionVersionOrder
	filter func(*TemplateSectionVersionQuery) (*TemplateSectionVersionQuery, error)
}

func newTemplateSectionVersionPager(opts []TemplateSectionVersionPaginateOption) (*templateSectionVersionPager, error) {
	pager := &templateSectionVersionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateSectionVersionOrder
	}
	return pager, nil
}

func (p *templateSectionVersionPager) applyFilter(query *TemplateSectionVersionQuery) (*TemplateSectionVersionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templateSectionVersionPager) toCursor(tsv *TemplateSectionVersion) Cursor {
	return p.order.Field.toCursor(tsv)
}

func (p *templateSectionVersionPager) applyCursors(query *TemplateSectionVersionQuery, after, before *Cursor) *TemplateSectionVersionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTemplateSectionVersionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *templateSectionVersionPager) applyOrder(query *TemplateSectionVersionQuery, reverse bool) *TemplateSectionVersionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTemplateSectionVersionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTemplateSectionVersionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TemplateSectionVersion.
func (tsv *TemplateSectionVersionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateSectionVersionPaginateOption,
) (*TemplateSectionVersionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateSectionVersionPager(opts)
	if err != nil {
		return nil, err
	}

	if tsv, err = pager.applyFilter(tsv); err != nil {
		return nil, err
	}

	conn := &TemplateSectionVersionConnection{Edges: []*TemplateSectionVersionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tsv.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tsv.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tsv = pager.applyCursors(tsv, after, before)
	tsv = pager.applyOrder(tsv, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tsv = tsv.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tsv = tsv.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tsv.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TemplateSectionVersion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateSectionVersion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateSectionVersion {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TemplateSectionVersionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TemplateSectionVersionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TemplateSectionVersionOrderFieldCreatedAt orders TemplateSectionVersion by created_at.
	TemplateSectionVersionOrderFieldCreatedAt = &TemplateSectionVersionOrderField{
		field: templatesectionversion.FieldCreatedAt,
		toCursor: func(tsv *TemplateSectionVersion) Cursor {
			return Cursor{
				ID:    tsv.ID,
				Value: tsv.CreatedAt,
			}
		},
	}
	// TemplateSectionVersionOrderFieldUpdatedAt orders TemplateSectionVersion by updated_at.
	TemplateSectionVersionOrderFieldUpdatedAt = &TemplateSectionVersionOrderField{
		field: templatesectionversion.FieldUpdatedAt,
		toCursor: func(tsv *TemplateSectionVersion) Cursor {
			return Cursor{
				ID:    tsv.ID,
				Value: tsv.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateSectionVersionOrderField) String() string {
	var str string
	switch f.field {
	case templatesectionversion.FieldCreatedAt:
		str = "CREATED_AT"
	case templatesectionversion.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateSectionVersionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateSectionVersionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateSectionVersionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TemplateSectionVersionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TemplateSectionVersionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TemplateSectionVersionOrderField", str)
	}
	return nil
}

// TemplateSectionVersionOrderField defines the ordering field of TemplateSectionVersion.
type TemplateSectionVersionOrderField struct {
	field    string
	toCursor func(*TemplateSectionVersion) Cursor
}

// TemplateSectionVersionOrder defines the ordering of TemplateSectionVersion.
type TemplateSectionVersionOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *TemplateSectionVersionOrderField `json:"field"`
}

// DefaultTemplateSectionVersionOrder is the default ordering of TemplateSectionVersion.
var DefaultTemplateSectionVersionOrder = &TemplateSectionVersionOrder{
	Direction: OrderDirectionAsc,
	Field: &TemplateSectionVersionOrderField{
		field: templatesectionversion.FieldID,
		toCursor: func(tsv *TemplateSectionVersion) Cursor {
			return Cursor{ID: tsv.ID}
		},
	},
}

// ToEdge converts TemplateSectionVersion into TemplateSectionVersionEdge.
func (tsv *TemplateSectionVersion) ToEdge(order *TemplateSectionVersionOrder) *TemplateSectionVersionEdge {
	if order == nil {
		order = DefaultTemplateSectionVersionOrder
	}
	return &TemplateSectionVersionEdge{
		Node:   tsv,
		Cursor: order.Field.toCursor(tsv),
	}
}

// ThemeEdge is the edge representation of Theme.
type ThemeEdge struct {
	Node   *Theme `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ThemeConnection is the connection containing edges to Theme.
type ThemeConnection struct {
	Edges      []*ThemeEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// ThemePaginateOption enables pagination customization.
type ThemePaginateOption func(*themePager) error

// WithThemeOrder configures pagination ordering.
func WithThemeOrder(order *ThemeOrder) ThemePaginateOption {
	if order == nil {
		order = DefaultThemeOrder
	}
	o := *order
	return func(pager *themePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultThemeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithThemeFilter configures pagination filter.
func WithThemeFilter(filter func(*ThemeQuery) (*ThemeQuery, error)) ThemePaginateOption {
	return func(pager *themePager) error {
		if filter == nil {
			return errors.New("ThemeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type themePager struct {
	order  *ThemeOrder
	filter func(*ThemeQuery) (*ThemeQuery, error)
}

func newThemePager(opts []ThemePaginateOption) (*themePager, error) {
	pager := &themePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultThemeOrder
	}
	return pager, nil
}

func (p *themePager) applyFilter(query *ThemeQuery) (*ThemeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *themePager) toCursor(t *Theme) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *themePager) applyCursors(query *ThemeQuery, after, before *Cursor) *ThemeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultThemeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *themePager) applyOrder(query *ThemeQuery, reverse bool) *ThemeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultThemeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultThemeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Theme.
func (t *ThemeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ThemePaginateOption,
) (*ThemeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newThemePager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &ThemeConnection{Edges: []*ThemeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Theme
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Theme {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Theme {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ThemeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ThemeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ThemeOrderFieldCreatedAt orders Theme by created_at.
	ThemeOrderFieldCreatedAt = &ThemeOrderField{
		field: theme.FieldCreatedAt,
		toCursor: func(t *Theme) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// ThemeOrderFieldUpdatedAt orders Theme by updated_at.
	ThemeOrderFieldUpdatedAt = &ThemeOrderField{
		field: theme.FieldUpdatedAt,
		toCursor: func(t *Theme) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ThemeOrderField) String() string {
	var str string
	switch f.field {
	case theme.FieldCreatedAt:
		str = "CREATED_AT"
	case theme.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ThemeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ThemeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ThemeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ThemeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ThemeOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ThemeOrderField", str)
	}
	return nil
}

// ThemeOrderField defines the ordering field of Theme.
type ThemeOrderField struct {
	field    string
	toCursor func(*Theme) Cursor
}

// ThemeOrder defines the ordering of Theme.
type ThemeOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ThemeOrderField `json:"field"`
}

// DefaultThemeOrder is the default ordering of Theme.
var DefaultThemeOrder = &ThemeOrder{
	Direction: OrderDirectionAsc,
	Field: &ThemeOrderField{
		field: theme.FieldID,
		toCursor: func(t *Theme) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Theme into ThemeEdge.
func (t *Theme) ToEdge(order *ThemeOrder) *ThemeEdge {
	if order == nil {
		order = DefaultThemeOrder
	}
	return &ThemeEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// ThemeTemplateEdge is the edge representation of ThemeTemplate.
type ThemeTemplateEdge struct {
	Node   *ThemeTemplate `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ThemeTemplateConnection is the connection containing edges to ThemeTemplate.
type ThemeTemplateConnection struct {
	Edges      []*ThemeTemplateEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// ThemeTemplatePaginateOption enables pagination customization.
type ThemeTemplatePaginateOption func(*themeTemplatePager) error

// WithThemeTemplateOrder configures pagination ordering.
func WithThemeTemplateOrder(order *ThemeTemplateOrder) ThemeTemplatePaginateOption {
	if order == nil {
		order = DefaultThemeTemplateOrder
	}
	o := *order
	return func(pager *themeTemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultThemeTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithThemeTemplateFilter configures pagination filter.
func WithThemeTemplateFilter(filter func(*ThemeTemplateQuery) (*ThemeTemplateQuery, error)) ThemeTemplatePaginateOption {
	return func(pager *themeTemplatePager) error {
		if filter == nil {
			return errors.New("ThemeTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type themeTemplatePager struct {
	order  *ThemeTemplateOrder
	filter func(*ThemeTemplateQuery) (*ThemeTemplateQuery, error)
}

func newThemeTemplatePager(opts []ThemeTemplatePaginateOption) (*themeTemplatePager, error) {
	pager := &themeTemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultThemeTemplateOrder
	}
	return pager, nil
}

func (p *themeTemplatePager) applyFilter(query *ThemeTemplateQuery) (*ThemeTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *themeTemplatePager) toCursor(tt *ThemeTemplate) Cursor {
	return p.order.Field.toCursor(tt)
}

func (p *themeTemplatePager) applyCursors(query *ThemeTemplateQuery, after, before *Cursor) *ThemeTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultThemeTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *themeTemplatePager) applyOrder(query *ThemeTemplateQuery, reverse bool) *ThemeTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultThemeTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultThemeTemplateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ThemeTemplate.
func (tt *ThemeTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ThemeTemplatePaginateOption,
) (*ThemeTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newThemeTemplatePager(opts)
	if err != nil {
		return nil, err
	}

	if tt, err = pager.applyFilter(tt); err != nil {
		return nil, err
	}

	conn := &ThemeTemplateConnection{Edges: []*ThemeTemplateEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tt = pager.applyCursors(tt, after, before)
	tt = pager.applyOrder(tt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tt = tt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tt = tt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ThemeTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ThemeTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ThemeTemplate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ThemeTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ThemeTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ThemeTemplateOrderFieldCreatedAt orders ThemeTemplate by created_at.
	ThemeTemplateOrderFieldCreatedAt = &ThemeTemplateOrderField{
		field: themetemplate.FieldCreatedAt,
		toCursor: func(tt *ThemeTemplate) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.CreatedAt,
			}
		},
	}
	// ThemeTemplateOrderFieldUpdatedAt orders ThemeTemplate by updated_at.
	ThemeTemplateOrderFieldUpdatedAt = &ThemeTemplateOrderField{
		field: themetemplate.FieldUpdatedAt,
		toCursor: func(tt *ThemeTemplate) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.UpdatedAt,
			}
		},
	}
	// ThemeTemplateOrderFieldName orders ThemeTemplate by name.
	ThemeTemplateOrderFieldName = &ThemeTemplateOrderField{
		field: themetemplate.FieldName,
		toCursor: func(tt *ThemeTemplate) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.Name,
			}
		},
	}
	// ThemeTemplateOrderFieldPageType orders ThemeTemplate by page_type.
	ThemeTemplateOrderFieldPageType = &ThemeTemplateOrderField{
		field: themetemplate.FieldPageType,
		toCursor: func(tt *ThemeTemplate) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.PageType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ThemeTemplateOrderField) String() string {
	var str string
	switch f.field {
	case themetemplate.FieldCreatedAt:
		str = "CREATED_AT"
	case themetemplate.FieldUpdatedAt:
		str = "UPDATED_AT"
	case themetemplate.FieldName:
		str = "NAME"
	case themetemplate.FieldPageType:
		str = "PAGE_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ThemeTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ThemeTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ThemeTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ThemeTemplateOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ThemeTemplateOrderFieldUpdatedAt
	case "NAME":
		*f = *ThemeTemplateOrderFieldName
	case "PAGE_TYPE":
		*f = *ThemeTemplateOrderFieldPageType
	default:
		return fmt.Errorf("%s is not a valid ThemeTemplateOrderField", str)
	}
	return nil
}

// ThemeTemplateOrderField defines the ordering field of ThemeTemplate.
type ThemeTemplateOrderField struct {
	field    string
	toCursor func(*ThemeTemplate) Cursor
}

// ThemeTemplateOrder defines the ordering of ThemeTemplate.
type ThemeTemplateOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ThemeTemplateOrderField `json:"field"`
}

// DefaultThemeTemplateOrder is the default ordering of ThemeTemplate.
var DefaultThemeTemplateOrder = &ThemeTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &ThemeTemplateOrderField{
		field: themetemplate.FieldID,
		toCursor: func(tt *ThemeTemplate) Cursor {
			return Cursor{ID: tt.ID}
		},
	},
}

// ToEdge converts ThemeTemplate into ThemeTemplateEdge.
func (tt *ThemeTemplate) ToEdge(order *ThemeTemplateOrder) *ThemeTemplateEdge {
	if order == nil {
		order = DefaultThemeTemplateOrder
	}
	return &ThemeTemplateEdge{
		Node:   tt,
		Cursor: order.Field.toCursor(tt),
	}
}

// TodoEdge is the edge representation of Todo.
type TodoEdge struct {
	Node   *Todo  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TodoConnection is the connection containing edges to Todo.
type TodoConnection struct {
	Edges      []*TodoEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// TodoPaginateOption enables pagination customization.
type TodoPaginateOption func(*todoPager) error

// WithTodoOrder configures pagination ordering.
func WithTodoOrder(order *TodoOrder) TodoPaginateOption {
	if order == nil {
		order = DefaultTodoOrder
	}
	o := *order
	return func(pager *todoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTodoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTodoFilter configures pagination filter.
func WithTodoFilter(filter func(*TodoQuery) (*TodoQuery, error)) TodoPaginateOption {
	return func(pager *todoPager) error {
		if filter == nil {
			return errors.New("TodoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type todoPager struct {
	order  *TodoOrder
	filter func(*TodoQuery) (*TodoQuery, error)
}

func newTodoPager(opts []TodoPaginateOption) (*todoPager, error) {
	pager := &todoPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTodoOrder
	}
	return pager, nil
}

func (p *todoPager) applyFilter(query *TodoQuery) (*TodoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *todoPager) toCursor(t *Todo) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *todoPager) applyCursors(query *TodoQuery, after, before *Cursor) *TodoQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTodoOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *todoPager) applyOrder(query *TodoQuery, reverse bool) *TodoQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTodoOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTodoOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Todo.
func (t *TodoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TodoPaginateOption,
) (*TodoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTodoPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TodoConnection{Edges: []*TodoEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Todo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Todo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Todo {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TodoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TodoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TodoOrderFieldCreatedAt orders Todo by created_at.
	TodoOrderFieldCreatedAt = &TodoOrderField{
		field: todo.FieldCreatedAt,
		toCursor: func(t *Todo) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TodoOrderFieldUpdatedAt orders Todo by updated_at.
	TodoOrderFieldUpdatedAt = &TodoOrderField{
		field: todo.FieldUpdatedAt,
		toCursor: func(t *Todo) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TodoOrderFieldText orders Todo by text.
	TodoOrderFieldText = &TodoOrderField{
		field: todo.FieldText,
		toCursor: func(t *Todo) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Text,
			}
		},
	}
	// TodoOrderFieldStatus orders Todo by status.
	TodoOrderFieldStatus = &TodoOrderField{
		field: todo.FieldStatus,
		toCursor: func(t *Todo) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Status,
			}
		},
	}
	// TodoOrderFieldPriority orders Todo by priority.
	TodoOrderFieldPriority = &TodoOrderField{
		field: todo.FieldPriority,
		toCursor: func(t *Todo) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Priority,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TodoOrderField) String() string {
	var str string
	switch f.field {
	case todo.FieldCreatedAt:
		str = "CREATED_AT"
	case todo.FieldUpdatedAt:
		str = "UPDATED_AT"
	case todo.FieldText:
		str = "TEXT"
	case todo.FieldStatus:
		str = "STATUS"
	case todo.FieldPriority:
		str = "PRIORITY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TodoOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TodoOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TodoOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TodoOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TodoOrderFieldUpdatedAt
	case "TEXT":
		*f = *TodoOrderFieldText
	case "STATUS":
		*f = *TodoOrderFieldStatus
	case "PRIORITY":
		*f = *TodoOrderFieldPriority
	default:
		return fmt.Errorf("%s is not a valid TodoOrderField", str)
	}
	return nil
}

// TodoOrderField defines the ordering field of Todo.
type TodoOrderField struct {
	field    string
	toCursor func(*Todo) Cursor
}

// TodoOrder defines the ordering of Todo.
type TodoOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TodoOrderField `json:"field"`
}

// DefaultTodoOrder is the default ordering of Todo.
var DefaultTodoOrder = &TodoOrder{
	Direction: OrderDirectionAsc,
	Field: &TodoOrderField{
		field: todo.FieldID,
		toCursor: func(t *Todo) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Todo into TodoEdge.
func (t *Todo) ToEdge(order *TodoOrder) *TodoEdge {
	if order == nil {
		order = DefaultTodoOrder
	}
	return &TodoEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}
